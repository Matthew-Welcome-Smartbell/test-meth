<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Live Crypto FGI (Option 1: No API Keys)</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 16px; }
    .card { border: 1px solid #ddd; border-radius: 12px; padding: 12px; margin-bottom: 12px; }
    .row { display:flex; gap:12px; flex-wrap:wrap; align-items:flex-start; }
    .col { flex:1 1 220px; }
    .muted { color: #666; }
    .small { font-size: 12px; }
    .pill { display:inline-block; padding:2px 8px; border-radius:999px; border:1px solid #ddd; font-size:12px; }
    canvas { width: 100%; max-height: 320px; }

    table { width: 100%; border-collapse: collapse; }
    th, td { text-align: left; padding: 8px; border-bottom: 1px solid #eee; font-size: 14px; }

    /* FGI tiles */
    .tile { border: 1px solid #eee; border-radius: 12px; padding: 10px; }
    .tileTitle { font-size: 12px; color: #666; margin-bottom: 4px; }
    .tileVal { font-size: 40px; font-weight: 700; line-height: 1.05; }
    .tileMeta { font-size: 12px; color: #666; margin-top: 4px; }

    /* warnings */
    .warnBox { margin-top: 10px; padding: 10px; border-radius: 10px; border: 1px solid; }
    .warnRed { background: #fff1f1; border-color: #f0b5b5; color: #7a0000; font-weight: 700; }
    .warnYellow { background: #fff9e6; border-color: #f0d48a; color: #6a5200; font-weight: 700; }

    /* weights UI */
    input[type="number"] { width: 120px; padding: 6px; border: 1px solid #ddd; border-radius: 8px; }
    button { padding: 8px 10px; border-radius: 10px; border: 1px solid #ddd; background: #f7f7f7; cursor: pointer; }
    button:hover { background: #efefef; }
    .err { color: #a40000; }

    /* forecasts */
    .forecastGrid { display:grid; grid-template-columns: 1fr 1fr; gap:10px; margin-top:10px; }
    .forecastBox { border: 1px solid #eee; border-radius: 10px; padding: 10px; }
    .forecastTitle { font-size: 12px; color:#666; margin-bottom:6px; }
    .forecastLine { font-size: 13px; margin: 3px 0; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
  </style>
</head>
<body>

  <div class="card">
    <div class="row">
      <div class="col" style="flex:1 1 280px;">
        <div class="muted">Connection</div>
        <div id="conn" class="pill">disconnected</div>
        <div class="muted small" style="margin-top:8px;">
          Binance REST: <code>/api/v3/klines</code> (1m + 1d)<br/>
          Binance WS: <code>aggTrade</code> + <code>depth10</code><br/>
          Alternative.me: public API (no key)<br/>
          This page uses <b>No API keys</b>.
        </div>
      </div>

      <div class="col" style="flex: 3 1 560px;">
        <div class="muted">Fear &amp; Greed (Option 1: MyFGI + Alternative.me only)</div>

        <div class="row" style="margin-top:10px;">
          <div class="col tile" style="flex:1 1 260px;">
            <div class="tileTitle">Average FGI (renormalized: 0.10 My + 0.45 Alt)</div>
            <div id="avgFgi" class="tileVal">--</div>
            <div id="avgMeta" class="tileMeta"></div>
          </div>

          <div class="col tile" style="flex:1 1 220px;">
            <div class="tileTitle">MyFGI (BTC/ETH basket)</div>
            <div id="myFgi" class="tileVal">--</div>
            <div id="myMeta" class="tileMeta"></div>
          </div>

          <div class="col tile" style="flex:1 1 220px;">
            <div class="tileTitle">Alternative.me FGI</div>
            <div id="altFgi" class="tileVal">--</div>
            <div id="altMeta" class="tileMeta"></div>
          </div>
        </div>

        <div id="priceStats" class="muted small" style="margin-top:10px;"></div>

        <!-- NEW: Forecasts -->
        <div id="fgiAverages" class="muted small" style="margin-top:8px;"></div>
        <div id="forecastStatus" class="muted small" style="margin-top:6px;"></div>

        <div class="forecastGrid">
          <div class="forecastBox">
            <div class="forecastTitle">BTC forecasts (FGI-drift model)</div>
            <div id="btcForecast" class="small"></div>
          </div>
          <div class="forecastBox">
            <div class="forecastTitle">ETH forecasts (FGI-drift model)</div>
            <div id="ethForecast" class="small"></div>
          </div>
        </div>

        <div id="warnRed" class="warnBox warnRed" style="display:none;"></div>
        <div id="warnY1" class="warnBox warnYellow" style="display:none;"></div>
        <div id="warnY2" class="warnBox warnYellow" style="display:none;"></div>
      </div>
    </div>
  </div>

  <div class="card">
    <div class="muted">MyFGI history (last 24h, 1 point/min). Backfill fetch uses last 72h to support “3+ days” warnings.</div>
    <canvas id="chart"></canvas>
    <div id="backfill" class="muted small" style="margin-top:8px;"></div>
    <div class="small muted" style="margin-top:6px;">
      Note: Binance does not provide historical order book. MyFGI backfill uses a candle-based proxy for OB; live uses real depth10 imbalance.
    </div>
  </div>

  <div class="card">
    <div class="muted">MyFGI basket weights (BTC/ETH only; auto-normalized)</div>
    <div class="row" style="margin-top:10px;">
      <div class="col">
        <div class="small muted">BTCUSDT</div>
        <input id="w_BTCUSDT" type="number" step="0.01" min="0" value="0.50"/>
      </div>
      <div class="col">
        <div class="small muted">ETHUSDT</div>
        <input id="w_ETHUSDT" type="number" step="0.01" min="0" value="0.50"/>
      </div>
    </div>
    <div class="row" style="margin-top:10px; align-items:center;">
      <button id="btnNormalize" type="button">Normalize</button>
      <button id="btnApply" type="button">Apply (recompute MyFGI chart + live)</button>
      <span id="wStatus" class="small muted"></span>
      <span id="wError" class="small err"></span>
    </div>
  </div>

  <div class="card">
    <div class="muted">Live per-asset components (MyFGI, computed from Binance WS)</div>
    <table>
      <thead>
        <tr>
          <th>Symbol</th><th>Price</th><th>Asset</th><th>Mom</th><th>Vol</th><th>OB</th><th>Agg</th>
        </tr>
      </thead>
      <tbody id="rows"></tbody>
    </table>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script>
    // ============================
    // CONFIG
    // ============================
    const SYMBOLS = ["BTCUSDT", "ETHUSDT"];

    // MyFGI weights (mutable via UI)
    let WEIGHTS = { "BTCUSDT": 0.50, "ETHUSDT": 0.50 };

    // Average weights requested: renormalize using only available sources (my + alt)
    const AVG_W_DESIRED = { my: 0.10, alt: 0.45 }; // sum=0.55; renormalize on availability

    const ALT_URL = "https://api.alternative.me/fng/?limit=500&format=json"; // enough history for 7d and more

    const LIVE_UPDATE_EVERY_MS = 5000;
    const CHART_POINT_SECONDS = 60;

    // Smoothing
    const BASKET_ALPHA_LIVE = 0.10;
    const ALPHA_BACKFILL = 0.10;

    // -------- NEW: Forecast model constants (from your Python logic)
    const YEARS_LOOKBACK = 3;
    const DAYS_LOOKBACK = Math.round(365.25 * YEARS_LOOKBACK); // ~1096
    const K_MULT = 18.0; // same knob as Python
    const DT_DAYS = 1.0;

    // MyFGI params (seconds)
    const P = {
      mom_short_s: 120,
      mom_long_s: 3600,
      vol_short_s: 240,
      vol_long_s: 3600,
      imb_window_s: 20,
      aggr_window_s: 1200,

      k_m_short: 0.005,
      k_m_long: 0.02,
      k_v_short: 0.01,
      k_v_long: 0.02,

      mom_blend_short: 0.5,
      vol_blend_short: 0.5,

      w_mom: 0.35,
      w_vol: 0.25,
      w_ob: 0.20,
      w_aggr: 0.20,
    };

    const EPS = 1e-12;

    // ============================
    // HELPERS
    // ============================
    function clamp(x, lo=0, hi=100) {
      x = Number(x);
      if (!Number.isFinite(x)) return lo;
      return Math.max(lo, Math.min(hi, x));
    }

    function tanhScoreSigned(x, k) { return clamp(50 + 50 * Math.tanh(x / (k + EPS))); }
    function tanhScoreNegative(x, k) { return clamp(50 + 50 * Math.tanh((-x) / (k + EPS))); }

    function std(arr) {
      const n = arr.length;
      if (!n) return 0;
      let mean = 0;
      for (const v of arr) mean += v;
      mean /= n;
      let ss = 0;
      for (const v of arr) { const d = v - mean; ss += d*d; }
      return Math.sqrt(ss / n);
    }

    function fmt(x, d=2) {
      if (x === null || x === undefined || !Number.isFinite(x)) return "--";
      return Number(x).toFixed(d);
    }

    function colorForFGI(v) {
      if (!Number.isFinite(v)) return "black";
      if (v >= 60) return "red";
      if (v <= 40) return "green";
      return "black";
    }

    function setConn(status) {
      const el = document.getElementById("conn");
      el.textContent = status;
      el.style.background = (status === "connected") ? "#eef9ee" : "#fff3f3";
      el.style.borderColor = (status === "connected") ? "#b8e0b8" : "#f0b5b5";
    }

    function setTile(idVal, idMeta, v, meta) {
      const valEl = document.getElementById(idVal);
      const metaEl = document.getElementById(idMeta);
      valEl.textContent = fmt(v, 2);
      valEl.style.color = colorForFGI(v);
      metaEl.textContent = meta || "";
    }

    function normalizeWeights(obj) {
      const clean = {};
      let sum = 0;
      for (const sym of SYMBOLS) {
        const v = Number(obj[sym]);
        const w = (Number.isFinite(v) && v > 0) ? v : 0;
        clean[sym] = w;
        sum += w;
      }
      if (sum <= 0) return { ok: false, weights: null, msg: "Weights sum to 0. Enter at least one positive weight." };
      for (const sym of SYMBOLS) clean[sym] = clean[sym] / sum;
      return { ok: true, weights: clean, msg: "Normalized (sum=1)." };
    }

    function readWeightsFromUI() {
      return {
        "BTCUSDT": Number(document.getElementById("w_BTCUSDT").value),
        "ETHUSDT": Number(document.getElementById("w_ETHUSDT").value),
      };
    }

    function writeWeightsToUI(w) {
      document.getElementById("w_BTCUSDT").value = (Number(w["BTCUSDT"]) || 0).toFixed(4);
      document.getElementById("w_ETHUSDT").value = (Number(w["ETHUSDT"]) || 0).toFixed(4);
    }

    function setWeightStatus(msg, isError=false) {
      document.getElementById("wStatus").textContent = isError ? "" : msg;
      document.getElementById("wError").textContent = isError ? msg : "";
    }

    function weightsSummary() {
      return SYMBOLS.map(s => `${s}=${(WEIGHTS[s]*100).toFixed(1)}%`).join(" ");
    }

    function update24hStatsFromChart(chart) {
      const data = chart?.data?.datasets?.[0]?.data || [];
      if (!data.length) return { hi: null, lo: null, avg: null, n: 0 };

      let hi = -Infinity, lo = Infinity, sum = 0, n = 0;
      for (const v of data) {
        const x = Number(v);
        if (!Number.isFinite(x)) continue;
        if (x > hi) hi = x;
        if (x < lo) lo = x;
        sum += x; n++;
      }
      if (!n) return { hi: null, lo: null, avg: null, n: 0 };
      return { hi, lo, avg: sum/n, n };
    }

    function dayKeyUTC(tSec) {
      const d = new Date(tSec * 1000);
      return `${d.getUTCFullYear()}-${String(d.getUTCMonth()+1).padStart(2,"0")}-${String(d.getUTCDate()).padStart(2,"0")}`;
    }

    function avgLastN(arr, n) {
      const a = (arr || []).filter(x => Number.isFinite(x));
      if (a.length < n) return NaN;
      const slice = a.slice(-n);
      const sum = slice.reduce((p,c)=>p+c,0);
      return sum / slice.length;
    }

    function setHtml(id, html) {
      const el = document.getElementById(id);
      if (el) el.innerHTML = html;
    }

    // ============================
    // BINANCE REST
    // ============================
    async function fetchKlines(symbol, interval, startMs, endMs, limit=1000) {
      const url = new URL("https://api.binance.com/api/v3/klines");
      url.searchParams.set("symbol", symbol);
      url.searchParams.set("interval", interval);
      if (startMs != null) url.searchParams.set("startTime", String(startMs));
      if (endMs != null) url.searchParams.set("endTime", String(endMs));
      url.searchParams.set("limit", String(limit));

      const res = await fetch(url.toString(), { method: "GET" });
      if (!res.ok) {
        const txt = await res.text().catch(() => "");
        throw new Error(`Klines fetch failed ${res.status}: ${txt}`);
      }
      return await res.json();
    }

    // Fetch last N minutes of 1m candles, paginated
    async function fetchLastNMinutes1m(symbol, minutes) {
      const now = Date.now();
      const start = now - minutes * 60 * 1000;
      const out = [];

      let cursor = start;
      const end = now;
      let guard = 0;

      while (cursor < end && guard < 40) {
        guard++;
        const batch = await fetchKlines(symbol, "1m", cursor, end, 1000);
        if (!batch.length) break;
        out.push(...batch);

        const lastOpen = batch[batch.length - 1][0];
        const next = lastOpen + 60 * 1000;
        if (next <= cursor) break;
        cursor = next;

        if (batch.length < 1000) break;
      }

      const map = new Map();
      for (const k of out) map.set(k[0], k);
      return Array.from(map.values()).sort((a,b)=>a[0]-b[0]);
    }

    async function fetchDailyCloses(symbol, days) {
      const now = Date.now();
      const start = now - days * 24 * 3600 * 1000;
      const kl = await fetchKlines(symbol, "1d", start, now, 1000);
      return kl.map(k => ({ tSec: Math.floor(k[0]/1000), close: Number(k[4]) }));
    }

    // -------- NEW: fetch ~3y daily closes (paged) for k-fit
    async function fetchDailyClosesPaged(symbol, daysWanted) {
      const now = Date.now();
      const start = now - daysWanted * 24 * 3600 * 1000;

      const out = [];
      let cursor = start;
      const end = now;
      let guard = 0;

      while (cursor < end && guard < 10) {
        guard++;
        const batch = await fetchKlines(symbol, "1d", cursor, end, 1000);
        if (!batch.length) break;

        out.push(...batch);
        const lastOpen = batch[batch.length - 1][0];
        const next = lastOpen + 24 * 3600 * 1000;
        if (next <= cursor) break;
        cursor = next;

        if (batch.length < 1000) break;
        // pacing
        await new Promise(r => setTimeout(r, 250));
      }

      // de-dup + sort
      const map = new Map();
      for (const k of out) map.set(k[0], k);
      const merged = Array.from(map.values()).sort((a,b)=>a[0]-b[0]);

      return merged.map(k => ({
        day: dayKeyUTC(Math.floor(k[0]/1000)),
        close: Number(k[4])
      }));
    }

    function klinesToSeries(klines) {
      const t = [], open=[], high=[], low=[], close=[], vol=[], takerBuy=[];
      for (const k of klines) {
        t.push(Math.floor(Number(k[0]) / 1000));
        open.push(Number(k[1])); high.push(Number(k[2])); low.push(Number(k[3]));
        close.push(Number(k[4])); vol.push(Number(k[5]));
        takerBuy.push(Number(k[9]));
      }
      return { t, open, high, low, close, vol, takerBuy };
    }

    // Compute per-minute asset scores from 1m candle data (approx core logic)
    function computeAssetFrom1m(series) {
      const { t, open, high, low, close, vol, takerBuy } = series;
      const n = t.length;

      const ret = new Array(n).fill(NaN);
      for (let i=1; i<n; i++) {
        const p0 = close[i-1], p1 = close[i];
        if (p0 > 0 && p1 > 0) ret[i] = Math.log(p1 / (p0 + EPS));
      }

      const ms = Math.max(1, Math.round(P.mom_short_s / 60));
      const ml = Math.max(1, Math.round(P.mom_long_s / 60));
      const vs = Math.max(1, Math.round(P.vol_short_s / 60));
      const vl = Math.max(1, Math.round(P.vol_long_s / 60));
      const iw = Math.max(1, Math.round(P.imb_window_s / 60));
      const aw = Math.max(1, Math.round(P.aggr_window_s / 60));

      const mom = new Array(n).fill(NaN);
      const volScore = new Array(n).fill(NaN);
      const ob = new Array(n).fill(NaN);
      const aggr = new Array(n).fill(NaN);
      const asset = new Array(n).fill(NaN);

      // Candle-based OB proxy imbalance in [-1,1]
      const imbProxy = new Array(n).fill(0);
      for (let i=0; i<n; i++) {
        const rng = (high[i] - low[i]);
        imbProxy[i] = (rng > 0) ? Math.max(-1, Math.min(1, (close[i] - open[i]) / (rng + EPS))) : 0;
      }

      for (let i=0; i<n; i++) {
        // Momentum
        if (i - ms >= 0 && close[i-ms] > 0 && close[i] > 0) {
          const rS = Math.log(close[i] / (close[i-ms] + EPS));
          const momS = tanhScoreSigned(rS, P.k_m_short);

          let momVal = momS;
          if (i - ml >= 0 && close[i-ml] > 0) {
            const rL = Math.log(close[i] / (close[i-ml] + EPS));
            const momL = tanhScoreSigned(rL, P.k_m_long);
            const a = clamp(P.mom_blend_short, 0, 1);
            momVal = a * momS + (1 - a) * momL;
          }
          mom[i] = momVal;
        }

        // Volatility
        const retsS = [];
        for (let j=Math.max(1, i - vs + 1); j<=i; j++) if (Number.isFinite(ret[j])) retsS.push(ret[j]);
        const volS = std(retsS);
        const volSScore = tanhScoreNegative(volS, P.k_v_short);

        const retsL = [];
        for (let j=Math.max(1, i - vl + 1); j<=i; j++) if (Number.isFinite(ret[j])) retsL.push(ret[j]);
        const volL = retsL.length ? std(retsL) : volS;
        const volLScore = tanhScoreNegative(volL, P.k_v_long);

        const aV = clamp(P.vol_blend_short, 0, 1);
        volScore[i] = aV * volSScore + (1 - aV) * volLScore;

        // OB proxy mean
        let sumImb = 0, cntImb = 0;
        for (let j=Math.max(0, i - iw + 1); j<=i; j++) { sumImb += imbProxy[j]; cntImb++; }
        ob[i] = clamp(50 + 50 * (cntImb ? (sumImb / cntImb) : 0));

        // Aggression proxy
        let bSum = 0, vSum = 0;
        for (let j=Math.max(0, i - aw + 1); j<=i; j++) { bSum += takerBuy[j]; vSum += vol[j]; }
        aggr[i] = (vSum > 0) ? clamp(100 * (bSum / (vSum + EPS))) : 50;

        if (Number.isFinite(mom[i])) {
          asset[i] = clamp(P.w_mom*mom[i] + P.w_vol*volScore[i] + P.w_ob*ob[i] + P.w_aggr*aggr[i]);
        }
      }

      return { t, close, asset };
    }

    // ============================
    // ALTERNATIVE.ME
    // ============================
    async function fetchAltFgiHistory() {
      const res = await fetch(ALT_URL, { method: "GET" });
      if (!res.ok) {
        const txt = await res.text().catch(()=> "");
        throw new Error(`Alternative.me fetch failed ${res.status}: ${txt}`);
      }
      const j = await res.json();
      const arr = j?.data || [];
      const parsed = arr
        .map(x => ({ tSec: Number(x.timestamp), value: Number(x.value), cls: String(x.value_classification||"") }))
        .filter(x => Number.isFinite(x.tSec) && Number.isFinite(x.value))
        .sort((a,b) => a.tSec-b.tSec); // oldest->newest
      return parsed;
    }

    // ============================
    // LIVE WS STATE (MyFGI live)
    // ============================
    class Rolling1s {
      constructor() { this.arr = []; } // {t, v}
      push(t, v) { this.arr.push({t, v}); }
      prune(cutoff) { while (this.arr.length && this.arr[0].t < cutoff) this.arr.shift(); }
      valuesSince(cutoff) { return this.arr.filter(x => x.t >= cutoff).map(x => x.v); }
      latest() { return this.arr.length ? this.arr[this.arr.length-1].v : null; }
    }

    class LiveSymbolState {
      constructor(symbol) {
        this.symbol = symbol;
        this.prices = new Rolling1s(); // per-second last price
        this.rets = new Rolling1s();   // per-second log returns
        this.buy1s = new Rolling1s();
        this.sell1s = new Rolling1s();
        this.imb = new Rolling1s();    // signed imbalance [-1,1] from depth10

        this.curSec = null;
        this.curPrice = null;
        this.curBuy = 0;
        this.curSell = 0;

        this._lastRetPrice = null;
        this.lastPrice = null;
      }

      keepSec() {
        return Math.max(P.mom_long_s, P.vol_long_s, P.aggr_window_s, P.imb_window_s, 600) + 60;
      }

      prune(nowSec) {
        const cutoff = nowSec - this.keepSec();
        this.prices.prune(cutoff);
        this.rets.prune(cutoff);
        this.buy1s.prune(cutoff);
        this.sell1s.prune(cutoff);
        this.imb.prune(nowSec - (P.imb_window_s + 120));
      }

      flushSecond(sec, price, buyQty, sellQty) {
        this.prices.push(sec, price);
        if (this._lastRetPrice != null && this._lastRetPrice > 0 && price > 0) {
          this.rets.push(sec, Math.log(price / (this._lastRetPrice + EPS)));
        }
        this._lastRetPrice = price;

        this.buy1s.push(sec, buyQty);
        this.sell1s.push(sec, sellQty);
      }

      onAggTrade(eventMs, price, qty, isBuyerMaker) {
        const sec = Math.floor(eventMs / 1000);
        price = Number(price); qty = Number(qty);
        this.lastPrice = price;

        if (this.curSec === null) {
          this.curSec = sec;
          this.curPrice = price;
          this.curBuy = 0; this.curSell = 0;
        }

        if (sec === this.curSec) {
          this.curPrice = price;
          if (isBuyerMaker) this.curSell += qty; else this.curBuy += qty;
          return;
        }

        this.flushSecond(this.curSec, Number(this.curPrice ?? price), this.curBuy, this.curSell);

        const gap = sec - this.curSec;
        const fillMax = 30;
        if (gap > 1) {
          const lastP = Number(this.curPrice ?? price);
          const fillTo = Math.min(sec - 1, this.curSec + fillMax);
          for (let s=this.curSec + 1; s<=fillTo; s++) this.flushSecond(s, lastP, 0, 0);
        }

        this.curSec = sec;
        this.curPrice = price;
        this.curBuy = 0; this.curSell = 0;
        if (isBuyerMaker) this.curSell += qty; else this.curBuy += qty;

        this.prune(sec);
      }

      onDepth10(eventMs, bids, asks) {
        const sec = Math.floor(eventMs / 1000);
        let sumB = 0, sumA = 0;
        for (let i=0; i<Math.min(10, bids.length); i++) sumB += Number(bids[i][1]);
        for (let i=0; i<Math.min(10, asks.length); i++) sumA += Number(asks[i][1]);
        const imb = (sumB - sumA) / (sumB + sumA + EPS);
        this.imb.push(sec, imb);
        this.prune(sec);
      }

      priceAtOrAfter(targetSec) {
        for (const x of this.prices.arr) { if (x.t >= targetSec) return x.v; }
        return null;
      }

      compute(nowSec) {
        this.prune(nowSec);

        const pNow = this.prices.latest();
        if (!(pNow > 0)) return null;

        const pS = this.priceAtOrAfter(nowSec - P.mom_short_s);
        if (!(pS > 0)) return null;

        const rS = Math.log(pNow / (pS + EPS));
        const momS = tanhScoreSigned(rS, P.k_m_short);

        let mom = momS;
        const pL = this.priceAtOrAfter(nowSec - P.mom_long_s);
        if (pL && pL > 0) {
          const rL = Math.log(pNow / (pL + EPS));
          const momL = tanhScoreSigned(rL, P.k_m_long);
          const a = clamp(P.mom_blend_short, 0, 1);
          mom = a * momS + (1 - a) * momL;
        }

        const retsS = this.rets.valuesSince(nowSec - P.vol_short_s);
        const volS = std(retsS);
        const volSScore = tanhScoreNegative(volS, P.k_v_short);

        const retsL = this.rets.valuesSince(nowSec - P.vol_long_s);
        const volL = retsL.length ? std(retsL) : volS;
        const volLScore = tanhScoreNegative(volL, P.k_v_long);

        const aV = clamp(P.vol_blend_short, 0, 1);
        const vol = aV * volSScore + (1 - aV) * volLScore;

        const imbs = this.imb.valuesSince(nowSec - P.imb_window_s);
        let ob = 50;
        if (imbs.length) {
          const mean = imbs.reduce((a,b)=>a+b,0) / imbs.length;
          ob = clamp(50 + 50 * mean);
        }

        const buys = this.buy1s.valuesSince(nowSec - P.aggr_window_s);
        const sells = this.sell1s.valuesSince(nowSec - P.aggr_window_s);
        const bSum = buys.reduce((a,b)=>a+b,0);
        const sSum = sells.reduce((a,b)=>a+b,0);
        const aggr = (bSum + sSum > 0) ? clamp(100 * (bSum / (bSum + sSum + EPS))) : 50;

        const asset = clamp(P.w_mom*mom + P.w_vol*vol + P.w_ob*ob + P.w_aggr*aggr);

        return { symbol: this.symbol, t_sec: nowSec, price: pNow, mom, vol, ob, aggr, asset };
      }
    }

    const liveStates = {};
    for (const s of SYMBOLS) liveStates[s] = new LiveSymbolState(s);

    // ============================
    // CHART
    // ============================
    let chart = null;
    function initChart() {
      const ctx = document.getElementById("chart").getContext("2d");
      chart = new Chart(ctx, {
        type: "line",
        data: { labels: [], datasets: [{ label: "MyFGI (1/min)", data: [], borderWidth: 2, pointRadius: 0, tension: 0.25 }] },
        options: { responsive: true, animation: false, scales: { y: { min: 0, max: 100 } } }
      });
    }

    // ============================
    // MYFGI BACKFILL CACHE (72h)
    // ============================
    let backfillCache = null;
    let myFgiSeries = [];     // [{t_sec, fgi_raw, fgi}]
    let prevBasketLive = 50.0;
    let lastChartMinute = null;

    async function loadMyFgiBackfill72h() {
      const el = document.getElementById("backfill");
      el.textContent = "MyFGI backfill: fetching 72h of 1m candles (BTC/ETH)…";

      const bySym = {};
      for (const sym of SYMBOLS) {
        el.textContent = `MyFGI backfill: fetching ${sym} 72h 1m…`;
        const kl = await fetchLastNMinutes1m(sym, 72*60);
        bySym[sym] = computeAssetFrom1m(klinesToSeries(kl));
      }

      const ref = bySym[SYMBOLS[0]].t;
      const has = {};
      for (const sym of SYMBOLS) has[sym] = new Set(bySym[sym].t);
      const commonT = ref.filter(ts => SYMBOLS.every(sym => has[sym].has(ts)));

      if (!commonT.length) {
        el.textContent = "MyFGI backfill: no overlapping timestamps across symbols.";
        backfillCache = null;
        return;
      }

      const idx = {};
      for (const sym of SYMBOLS) {
        idx[sym] = new Map();
        bySym[sym].t.forEach((ts, i) => idx[sym].set(ts, i));
      }

      backfillCache = { commonT, idx, bySym };
      el.textContent = `MyFGI backfill: cache ready (${commonT.length} minutes). Rendering MyFGI…`;

      recomputeMyFgiFromCache();
    }

    function recomputeMyFgiFromCache() {
      const el = document.getElementById("backfill");
      if (!backfillCache) { el.textContent = "MyFGI backfill: cache not ready."; return; }

      const { commonT, idx, bySym } = backfillCache;

      const out = [];
      let prev = 50.0;

      for (const ts of commonT) {
        let total = 0, used = 0;
        for (const sym of SYMBOLS) {
          const i = idx[sym].get(ts);
          const a = bySym[sym].asset[i];
          const w = Number(WEIGHTS[sym] || 0);
          if (Number.isFinite(a) && w > 0) { total += w * a; used += w; }
        }
        if (used <= 0) continue;

        const fgiRaw = clamp(total / (used + EPS));
        const fgi = clamp(ALPHA_BACKFILL * fgiRaw + (1 - ALPHA_BACKFILL) * prev);
        prev = fgi;
        out.push({ t_sec: ts, fgi_raw: fgiRaw, fgi });
      }

      myFgiSeries = out;

      const maxPts = 24*60;
      const slice = myFgiSeries.slice(-maxPts);

      chart.data.labels = [];
      chart.data.datasets[0].data = [];
      for (const p of slice) {
        chart.data.labels.push(new Date(p.t_sec*1000).toLocaleTimeString());
        chart.data.datasets[0].data.push(p.fgi);
      }
      chart.update("none");

      if (myFgiSeries.length) prevBasketLive = myFgiSeries[myFgiSeries.length-1].fgi;

      const stats = update24hStatsFromChart(chart);
      el.textContent =
        `MyFGI backfill: rendered ${slice.length} pts (24h). 24h high=${fmt(stats.hi)} low=${fmt(stats.lo)} avg=${fmt(stats.avg)}.`;
    }

    function computeMyFgiDailyAveragesLastNDays(nDays) {
      const map = new Map(); // dayKey -> {sum, n}
      for (const p of myFgiSeries) {
        const k = dayKeyUTC(p.t_sec);
        if (!map.has(k)) map.set(k, { sum: 0, n: 0 });
        const o = map.get(k);
        if (Number.isFinite(p.fgi)) { o.sum += p.fgi; o.n += 1; }
      }
      const days = Array.from(map.entries())
        .map(([k,v]) => ({ day: k, avg: (v.n ? v.sum/v.n : NaN) }))
        .filter(x => Number.isFinite(x.avg))
        .sort((a,b)=> a.day.localeCompare(b.day));
      return days.slice(-nDays);
    }

    // ============================
    // PRICE AVERAGES (BTC daily)
    // ============================
    let btcDailyCloses = null;
    let priceNowBTC = null;
    let priceNowETH = null;

    function avgLastNCloses(series, n) {
      if (!series || series.length < n) return null;
      const arr = series.slice(-n).map(x => x.close).filter(v => Number.isFinite(v));
      if (arr.length < n) return null;
      const sum = arr.reduce((a,b)=>a+b,0);
      return sum / arr.length;
    }

    async function loadBtcDailyCloses() {
      btcDailyCloses = await fetchDailyCloses("BTCUSDT", 120);
    }

    function updatePriceStatsUI() {
      const a7 = avgLastNCloses(btcDailyCloses, 7);
      const a30 = avgLastNCloses(btcDailyCloses, 30);
      const a60 = avgLastNCloses(btcDailyCloses, 60);
      const a90 = avgLastNCloses(btcDailyCloses, 90);

      const p = (priceNowBTC != null) ? priceNowBTC : (btcDailyCloses?.length ? btcDailyCloses[btcDailyCloses.length-1].close : null);

      document.getElementById("priceStats").textContent =
        `BTC price=${fmt(p, 2)} | 7d avg=${fmt(a7,2)} | 30d avg=${fmt(a30,2)} | 60d avg=${fmt(a60,2)} | 90d avg=${fmt(a90,2)}`;
      return { p, a30, a60 };
    }

    // ============================
    // AVERAGE FGI (My + Alt only)
    // ============================
    function computeAvgFgi(my, alt) {
      const wMy = Number(AVG_W_DESIRED.my || 0);
      const wAlt = Number(AVG_W_DESIRED.alt || 0);

      const hasMy = Number.isFinite(my);
      const hasAlt = Number.isFinite(alt);

      const sumAvail = (hasMy ? wMy : 0) + (hasAlt ? wAlt : 0);
      if (sumAvail <= 0) return { avg: NaN, meta: "avg unavailable (missing sources)" };

      const myN = hasMy ? (wMy / sumAvail) : 0;
      const altN = hasAlt ? (wAlt / sumAvail) : 0;

      const avg = clamp(myN*my + altN*alt);
      const meta = `using renormalized weights: my=${(myN*100).toFixed(1)}% alt=${(altN*100).toFixed(1)}%`;
      return { avg, meta };
    }

    // ============================
    // WARNINGS (unchanged here)
    // ============================
    function setWarn(id, show, msg) {
      const el = document.getElementById(id);
      if (!show) { el.style.display = "none"; el.textContent = ""; return; }
      el.style.display = "block";
      el.textContent = msg;
    }

    function evaluateWarnings(avgFgiNow, pricePack, avgFgiDailyLast3) {
      const p = pricePack.p;
      const a30 = pricePack.a30;
      const a60 = pricePack.a60;

      const red1 = (Number.isFinite(p) && Number.isFinite(a60) && p > a60 * 1.05 && Number.isFinite(avgFgiNow) && avgFgiNow < 40);
      const red2 = (Number.isFinite(p) && Number.isFinite(a30) && p > a30 * 1.10 && Number.isFinite(avgFgiNow) && avgFgiNow < 40);

      const redMsg = [];
      if (red1) redMsg.push(`price > 60d avg * 1.05 AND avg FGI < 40`);
      if (red2) redMsg.push(`price > 30d avg * 1.10 AND avg FGI < 40`);
      setWarn("warnRed", redMsg.length > 0, redMsg.length ? `RED WARNING: ${redMsg.join(" | ")}` : "");

      const y1 = (Number.isFinite(avgFgiNow) && avgFgiNow > 50);
      setWarn("warnY1", y1, y1 ? "WARNING: average FGI > 50, use reduced leverage" : "");

      let y2 = false;
      if (avgFgiDailyLast3 && avgFgiDailyLast3.length >= 3) {
        y2 = avgFgiDailyLast3.slice(-3).every(x => Number.isFinite(x.avg) && x.avg < 37);
      }
      setWarn("warnY2", y2, y2 ? "WARNING: FGI < 37 for 3 or more days, possible drawdown, use reduced leverage" : "");
    }

    // ============================
    // LIVE WS (Binance)
    // ============================
    let ws = null;
    let wsBackoffMs = 500;

    function connectWS() {
      const streams = [];
      for (const sym of SYMBOLS) {
        const s = sym.toLowerCase();
        streams.push(`${s}@aggTrade`);
        streams.push(`${s}@depth10@100ms`);
      }
      const url = `wss://stream.binance.com:9443/stream?streams=${streams.join("/")}`;
      ws = new WebSocket(url);

      ws.onopen = () => { setConn("connected"); wsBackoffMs = 500; };
      ws.onclose = () => {
        setConn("disconnected");
        setTimeout(connectWS, wsBackoffMs);
        wsBackoffMs = Math.min(15000, wsBackoffMs * 1.5);
      };
      ws.onerror = () => { try { ws.close(); } catch {} };

      ws.onmessage = (ev) => {
        let msg;
        try { msg = JSON.parse(ev.data); } catch { return; }
        const stream = msg.stream || "";
        const d = msg.data || {};

        const sym = stream.split("@")[0].toUpperCase();
        if (!liveStates[sym]) return;

        if (stream.endsWith("@aggTrade")) {
          liveStates[sym].onAggTrade(Number(d.E), Number(d.p), Number(d.q), Boolean(d.m));
          if (sym === "BTCUSDT") priceNowBTC = Number(d.p);
          if (sym === "ETHUSDT") priceNowETH = Number(d.p);
          return;
        }
        if (stream.includes("@depth10")) {
          liveStates[sym].onDepth10(Number(d.E), d.b || [], d.a || []);
          return;
        }
      };
    }

    // ============================
    // LIVE COMPUTE + UI
    // ============================
    function updateTable(snapshotAssets) {
      const rows = document.getElementById("rows");
      rows.innerHTML = "";
      const keys = Object.keys(snapshotAssets).sort();
      for (const k of keys) {
        const a = snapshotAssets[k];
        const tr = document.createElement("tr");
        tr.innerHTML =
          `<td>${k}</td>` +
          `<td>${fmt(a.price, 2)}</td>` +
          `<td>${fmt(a.asset, 2)}</td>` +
          `<td>${fmt(a.mom, 2)}</td>` +
          `<td>${fmt(a.vol, 2)}</td>` +
          `<td>${fmt(a.ob, 2)}</td>` +
          `<td>${fmt(a.aggr, 2)}</td>`;
        rows.appendChild(tr);
      }
    }

    function computeMyFgiLiveOnce() {
      const nowSec = Math.floor(Date.now() / 1000);

      const assets = {};
      let total = 0, used = 0;

      for (const sym of SYMBOLS) {
        const sc = liveStates[sym].compute(nowSec);
        if (!sc) continue;
        assets[sym] = sc;

        const w = Number(WEIGHTS[sym] || 0);
        if (w > 0) { total += w * sc.asset; used += w; }
      }

      if (used <= 0) return null;

      const fgiRaw = clamp(total / (used + EPS));
      const fgi = clamp(BASKET_ALPHA_LIVE * fgiRaw + (1 - BASKET_ALPHA_LIVE) * prevBasketLive);
      prevBasketLive = fgi;

      return { t_sec: nowSec, fgi_raw: fgiRaw, fgi, assets };
    }

    function maybeAppendChartPoint(mySnap) {
      const minute = Math.floor(mySnap.t_sec / CHART_POINT_SECONDS);
      if (lastChartMinute === null) lastChartMinute = minute;

      if (minute !== lastChartMinute) {
        lastChartMinute = minute;

        chart.data.labels.push(new Date(mySnap.t_sec * 1000).toLocaleTimeString());
        chart.data.datasets[0].data.push(mySnap.fgi);

        const maxPts = 24 * 60;
        while (chart.data.labels.length > maxPts) {
          chart.data.labels.shift();
          chart.data.datasets[0].data.shift();
        }
        chart.update("none");
      }
    }

    // ============================
    // EXTERNAL FGI STATE
    // ============================
    let altHistory = null; // [{tSec,value,cls}] oldest->newest
    let altNow = NaN;
    let altNowMeta = "";

    async function refreshAlt() {
      altHistory = await fetchAltFgiHistory();
      if (altHistory && altHistory.length) {
        const last = altHistory[altHistory.length - 1];
        altNow = clamp(last.value);
        altNowMeta = `${last.cls || ""} | ${new Date(last.tSec*1000).toLocaleString()}`;
      }
    }

    function computeAltDailyLastNDays(nDays) {
      if (!altHistory || altHistory.length < 1) return [];
      // altHistory is ~daily already; use last nDays entries
      const slice = altHistory.slice(-Math.max(nDays, 1));
      return slice.map(x => ({ day: dayKeyUTC(x.tSec), avg: clamp(x.value) }));
    }

    // ============================
    // NEW: k-fit for BTC & ETH in-browser (3y daily)
    // ============================
    let kModel = {
      BTCUSDT: { k_fit: NaN, k_used: NaN, days: 0, note: "" },
      ETHUSDT: { k_fit: NaN, k_used: NaN, days: 0, note: "" },
    };

    function buildAltFgiByDay() {
      const map = new Map(); // day -> value
      if (!altHistory) return map;
      for (const x of altHistory) {
        const day = dayKeyUTC(x.tSec);
        map.set(day, clamp(x.value));
      }
      return map;
    }

    function fitKLeastSquaresCentered(dailyCloses, fgiByDay) {
      // dailyCloses: [{day, close}]
      // Need aligned daily fgi series with forward fill
      let lastFgi = NaN;
      const fgi = [];
      const price = [];

      for (const row of dailyCloses) {
        const v = fgiByDay.get(row.day);
        if (Number.isFinite(v)) lastFgi = v;
        // forward-fill only if we have ever seen a finite
        fgi.push(Number.isFinite(lastFgi) ? lastFgi : NaN);
        price.push(Number(row.close));
      }

      let sumXY = 0;
      let sumXX = 0;
      let used = 0;

      for (let i = 1; i < price.length; i++) {
        const p0 = price[i-1], p1 = price[i];
        const fi = fgi[i];
        if (!(Number.isFinite(p0) && Number.isFinite(p1) && Number.isFinite(fi))) continue;

        const dP = (p1 - p0);
        const x = (fi - 50.0) * DT_DAYS; // dt=1
        sumXY += x * dP;
        sumXX += x * x;
        used++;
      }

      const k_fit = (sumXX > 0) ? (sumXY / sumXX) : NaN;
      return { k_fit, used };
    }

    async function buildKModelsOnce() {
      const statusEl = document.getElementById("forecastStatus");
      statusEl.textContent = "Forecast model: fitting k for BTC & ETH (3y daily)...";

      // ensure altHistory loaded
      if (!altHistory) await refreshAlt();
      const fgiByDay = buildAltFgiByDay();

      for (const sym of ["BTCUSDT", "ETHUSDT"]) {
        try {
          const daily = await fetchDailyClosesPaged(sym, DAYS_LOOKBACK + 10);
          const { k_fit, used } = fitKLeastSquaresCentered(daily, fgiByDay);
          const k_used = (Number.isFinite(k_fit) ? (k_fit * K_MULT) : NaN);

          kModel[sym] = {
            k_fit,
            k_used,
            days: daily.length,
            note: `used=${used} points`
          };
        } catch (e) {
          kModel[sym] = { k_fit: NaN, k_used: NaN, days: 0, note: `error: ${String(e.message || e)}` };
        }
      }

      statusEl.textContent =
        `Forecast model ready (Alt.me only). K_MULT=${K_MULT}. BTC k_used=${fmt(kModel.BTCUSDT.k_used, 4)} | ETH k_used=${fmt(kModel.ETHUSDT.k_used, 4)}`;
    }

    function forecastPrice(priceNow, k_used, fgiAvg, dtDays) {
      if (!(Number.isFinite(priceNow) && Number.isFinite(k_used) && Number.isFinite(fgiAvg))) return NaN;
      return priceNow + k_used * (fgiAvg - 50.0) * dtDays;
    }

    // ============================
    // NEW: compute 2D/7D average of "Average FGI" (my+alt renormalized)
    // ============================
    function computeAvgFgiDailySeriesLastNDays(nDays) {
      // Build daily series for last nDays using:
      // - MyFGI daily from myFgiSeries (up to 3 days from 72h backfill)
      // - Alt daily from altHistory (covers nDays)
      // Then compute daily "avg fgi" via computeAvgFgi() (renormalized if one missing).
      const myDaily = computeMyFgiDailyAveragesLastNDays(Math.max(nDays, 3)); // may return <=3
      const altDaily = computeAltDailyLastNDays(nDays);

      const byDay = new Map();
      for (const x of altDaily) byDay.set(x.day, { day: x.day, my: NaN, alt: x.avg });
      for (const x of myDaily) {
        const o = byDay.get(x.day) || { day: x.day, my: NaN, alt: NaN };
        o.my = x.avg;
        byDay.set(x.day, o);
      }

      const merged = Array.from(byDay.values()).sort((a,b)=>a.day.localeCompare(b.day));
      const out = [];
      for (const d of merged) {
        const r = computeAvgFgi(d.my, d.alt);
        if (Number.isFinite(r.avg)) out.push({ day: d.day, avg: r.avg });
      }
      return out.slice(-nDays);
    }

    function renderForecasts(avgDailySeries, avgNow) {
      // avgDailySeries: [{day, avg}] for last 7 days ideally
      const avgVals = avgDailySeries.map(x => x.avg);
      const fgi2 = avgLastN(avgVals, 2);
      const fgi7 = avgLastN(avgVals, 7);

      const now = new Date();
      const tomorrow = new Date(now.getTime() + 24*3600*1000);
      const week = new Date(now.getTime() + 7*24*3600*1000);

      const fgiAvgEl = document.getElementById("fgiAverages");
      fgiAvgEl.textContent =
        `Avg-FGI rolling (daily): 2D=${fmt(fgi2,2)} | 7D=${fmt(fgi7,2)} | current(avg tile)=${fmt(avgNow,2)} (2D/7D use daily avg series)`;

      const btcP = Number.isFinite(priceNowBTC) ? priceNowBTC : NaN;
      const ethP = Number.isFinite(priceNowETH) ? priceNowETH : NaN;

      const kB = kModel.BTCUSDT?.k_used;
      const kE = kModel.ETHUSDT?.k_used;

      const btc_tom_2 = forecastPrice(btcP, kB, fgi2, 1);
      const btc_tom_7 = forecastPrice(btcP, kB, fgi7, 1);
      const btc_wk_2  = forecastPrice(btcP, kB, fgi2, 7);
      const btc_wk_7  = forecastPrice(btcP, kB, fgi7, 7);

      const eth_tom_2 = forecastPrice(ethP, kE, fgi2, 1);
      const eth_tom_7 = forecastPrice(ethP, kE, fgi7, 1);
      const eth_wk_2  = forecastPrice(ethP, kE, fgi2, 7);
      const eth_wk_7  = forecastPrice(ethP, kE, fgi7, 7);

      const btcHtml = `
        <div class="forecastLine">price now: <span class="mono">${fmt(btcP,2)}</span></div>
        <div class="forecastLine">k_used: <span class="mono">${fmt(kB,6)}</span> <span class="muted small">(${kModel.BTCUSDT?.note || ""})</span></div>
        <div class="forecastLine">${tomorrow.toLocaleDateString()} (tomorrow) using 2D avg FGI: <span class="mono">${fmt(btc_tom_2,2)}</span></div>
        <div class="forecastLine">${tomorrow.toLocaleDateString()} (tomorrow) using 7D avg FGI: <span class="mono">${fmt(btc_tom_7,2)}</span></div>
        <div class="forecastLine">${week.toLocaleDateString()} (1 week) using 2D avg FGI: <span class="mono">${fmt(btc_wk_2,2)}</span></div>
        <div class="forecastLine">${week.toLocaleDateString()} (1 week) using 7D avg FGI: <span class="mono">${fmt(btc_wk_7,2)}</span></div>
      `;
      const ethHtml = `
        <div class="forecastLine">price now: <span class="mono">${fmt(ethP,2)}</span></div>
        <div class="forecastLine">k_used: <span class="mono">${fmt(kE,6)}</span> <span class="muted small">(${kModel.ETHUSDT?.note || ""})</span></div>
        <div class="forecastLine">${tomorrow.toLocaleDateString()} (tomorrow) using 2D avg FGI: <span class="mono">${fmt(eth_tom_2,2)}</span></div>
        <div class="forecastLine">${tomorrow.toLocaleDateString()} (tomorrow) using 7D avg FGI: <span class="mono">${fmt(eth_tom_7,2)}</span></div>
        <div class="forecastLine">${week.toLocaleDateString()} (1 week) using 2D avg FGI: <span class="mono">${fmt(eth_wk_2,2)}</span></div>
        <div class="forecastLine">${week.toLocaleDateString()} (1 week) using 7D avg FGI: <span class="mono">${fmt(eth_wk_7,2)}</span></div>
      `;

      setHtml("btcForecast", btcHtml);
      setHtml("ethForecast", ethHtml);
    }

    // ============================
    // WEIGHTS UI WIRING
    // ============================
    function initWeightsUI() {
      const r0 = normalizeWeights(WEIGHTS);
      if (r0.ok) WEIGHTS = r0.weights;

      writeWeightsToUI(WEIGHTS);
      setWeightStatus(`Current: ${weightsSummary()}`);

      document.getElementById("btnNormalize").onclick = () => {
        const raw = readWeightsFromUI();
        const r = normalizeWeights(raw);
        if (!r.ok) return setWeightStatus(r.msg, true);
        writeWeightsToUI(r.weights);
        setWeightStatus(`Normalized preview: BTC=${(r.weights["BTCUSDT"]*100).toFixed(1)}% ETH=${(r.weights["ETHUSDT"]*100).toFixed(1)}%`);
      };

      document.getElementById("btnApply").onclick = () => {
        setWeightStatus("Applying…");
        const raw = readWeightsFromUI();
        const r = normalizeWeights(raw);
        if (!r.ok) return setWeightStatus(r.msg, true);

        WEIGHTS = r.weights;
        writeWeightsToUI(WEIGHTS);

        // Recompute MyFGI backfill + reseed live EMA to avoid a jump
        recomputeMyFgiFromCache();
        lastChartMinute = null;

        setWeightStatus(`Applied: ${weightsSummary()}`);
      };
    }

    // ============================
    // BOOT
    // ============================
    (async () => {
      initChart();
      initWeightsUI();
      setConn("disconnected");

      try {
        await loadBtcDailyCloses();
      } catch (e) {
        document.getElementById("priceStats").textContent = `BTC daily load failed: ${String(e.message || e)}`;
      }

      try {
        await loadMyFgiBackfill72h();
      } catch (e) {
        document.getElementById("backfill").textContent = `MyFGI backfill failed: ${String(e.message || e)}`;
      }

      try {
        await refreshAlt();
      } catch (e) {
        altNow = NaN;
        altNowMeta = `Alternative.me fetch failed: ${String(e.message || e)}`;
      }

      // NEW: fit k-models once (3y)
      try {
        await buildKModelsOnce();
      } catch (e) {
        document.getElementById("forecastStatus").textContent =
          `Forecast model init failed: ${String(e.message || e)}`;
      }

      // Start WS
      connectWS();

      // Refresh external FGI occasionally
      setInterval(async () => {
        try { await refreshAlt(); } catch {}
      }, 60 * 1000);

      // Main loop
      setInterval(() => {
        const mySnap = computeMyFgiLiveOnce();
        if (!mySnap) return;

        // Update MyFGI tile
        setTile(
          "myFgi",
          "myMeta",
          mySnap.fgi,
          `raw=${fmt(mySnap.fgi_raw,2)} | alpha=${BASKET_ALPHA_LIVE} | weights: ${weightsSummary()} | ${new Date(mySnap.t_sec*1000).toLocaleString()}`
        );

        // Update Alt tile
        setTile("altFgi", "altMeta", altNow, altNowMeta);

        // Compute AVG (renormalized on available sources)
        const { avg, meta } = computeAvgFgi(mySnap.fgi, altNow);
        setTile("avgFgi", "avgMeta", avg, meta);

        // Update price stats + warnings (existing)
        const pricePack = updatePriceStatsUI();

        // Daily series for 3+ days check:
        const myDaily3 = computeMyFgiDailyAveragesLastNDays(3);
        const altDaily3 = computeAltDailyLastNDays(3);

        const byDay = new Map();
        for (const x of myDaily3) byDay.set(x.day, { day: x.day, my: x.avg, alt: NaN });
        for (const x of altDaily3) {
          const o = byDay.get(x.day) || { day: x.day, my: NaN, alt: NaN };
          o.alt = x.avg;
          byDay.set(x.day, o);
        }
        const dailyMerged3 = Array.from(byDay.values()).sort((a,b)=>a.day.localeCompare(b.day));
        const avgDaily3 = dailyMerged3.map(d => ({ day: d.day, avg: computeAvgFgi(d.my, d.alt).avg }))
                                     .filter(x => Number.isFinite(x.avg));

        evaluateWarnings(avg, pricePack, avgDaily3);

        // Update per-asset table
        updateTable(mySnap.assets);

        // Update chart
        maybeAppendChartPoint(mySnap);

        // NEW: forecasts using 2D and 7D avg of the *Average FGI* daily series
        const avgDaily7 = computeAvgFgiDailySeriesLastNDays(7);
        renderForecasts(avgDaily7, avg);

      }, LIVE_UPDATE_EVERY_MS);
    })();
  </script>
</body>
</html>
