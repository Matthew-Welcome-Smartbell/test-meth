<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Live Crypto FGI (BTC/ETH 50/50, 24h Backfill, No Storage)</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 16px; }
    .card { border: 1px solid #ddd; border-radius: 12px; padding: 12px; margin-bottom: 12px; }
    .big { font-size: 44px; font-weight: 700; }
    .muted { color: #666; }
    .row { display:flex; gap:12px; flex-wrap:wrap; align-items:flex-start; }
    .col { flex:1 1 220px; }
    table { width: 100%; border-collapse: collapse; }
    th, td { text-align: left; padding: 8px; border-bottom: 1px solid #eee; font-size: 14px; }
    .pill { display:inline-block; padding:2px 8px; border-radius:999px; border:1px solid #ddd; font-size:12px; }
    canvas { width: 100%; max-height: 320px; }
    .small { font-size: 12px; }
    code { background:#f7f7f7; padding:2px 4px; border-radius:6px; }
    .warn { color: #8a5a00; }
    input[type="number"] { width: 110px; padding: 6px; border: 1px solid #ddd; border-radius: 8px; }
    button { padding: 8px 10px; border-radius: 10px; border: 1px solid #ddd; background: #f7f7f7; cursor: pointer; }
    button:hover { background: #efefef; }
    .err { color: #a40000; }
    .ok  { color: #0b6b0b; }
    .grid2 { display:grid; grid-template-columns: 1fr 1fr; gap:10px; }
  </style>
</head>
<body>

  <div class="card">
    <div class="row">
      <div class="col">
        <div class="muted">Basket FGI (live updates every 5s; chart is 1/min)</div>
        <div id="fgi" class="big">--</div>
        <div id="meta" class="muted small"></div>
        <div id="stats" class="muted small"></div>
        <div id="backfill" class="muted small"></div>
        <div class="small warn" style="margin-top:6px;">
          Backfill uses candles only (no historical order book/trade aggressor available from public Binance endpoints in-browser).
          Live uses WS depth10 + aggTrade.
        </div>
      </div>
      <div class="col">
        <div class="muted">Connection</div>
        <div id="conn" class="pill">disconnected</div>
        <div class="muted small" style="margin-top:8px;">
          REST backfill: <code>/api/v3/klines</code> (1m)<br/>
          Live: <code>aggTrade</code> + <code>depth10</code>
        </div>
      </div>
    </div>
  </div>

  <!-- Weights UI (BTC/ETH only; must stay 50/50 by requirement) -->
  <div class="card">
    <div class="muted">Basket weights (fixed to BTC/ETH 50/50)</div>
    <div class="row" style="margin-top:10px;">
      <div class="col">
        <div class="small muted">BTCUSDT</div>
        <input id="w_BTCUSDT" type="number" step="0.01" min="0" value="0.50" disabled/>
      </div>
      <div class="col">
        <div class="small muted">ETHUSDT</div>
        <input id="w_ETHUSDT" type="number" step="0.01" min="0" value="0.50" disabled/>
      </div>
    </div>
    <div class="small muted" style="margin-top:6px;">
      Note: weights are intentionally locked to 50/50. (This keeps live and historic comparable and avoids “weight drift”.)
    </div>
  </div>

  <div class="card">
    <div class="muted">FGI history (last 24h, 1 point/min)</div>
    <div class="row" style="margin-top:8px;">
      <div class="col">
        <div class="small muted">Chart series</div>
        <div class="row" style="gap:8px;">
          <button id="btnShowSmoothed" type="button">Show smoothed</button>
          <button id="btnShowRaw" type="button">Show raw</button>
          <span id="seriesStatus" class="small muted"></span>
        </div>
      </div>
      <div class="col">
        <div class="small muted">Stats mode</div>
        <div class="row" style="gap:8px;">
          <button id="btnStatsSmoothed" type="button">Stats: smoothed</button>
          <button id="btnStatsRaw" type="button">Stats: raw</button>
          <span id="statsStatus" class="small muted"></span>
        </div>
      </div>
    </div>
    <canvas id="chart" style="margin-top:10px;"></canvas>
  </div>

  <div class="card">
    <div class="muted">Per-asset components (live)</div>
    <table>
      <thead>
        <tr>
          <th>Symbol</th><th>Price</th><th>Asset</th><th>Mom</th><th>Vol</th><th>OB</th><th>Agg</th>
        </tr>
      </thead>
      <tbody id="rows"></tbody>
    </table>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script>
    // ============================================================
    // CHANGES REQUESTED (implemented)
    // 1) Only BTC/ETH, fixed 50/50
    // 2) Backfill smoothing removed by default (raw is available)
    // 3) 24h stats can be computed from RAW (default) instead of smoothed
    // 4) Backfill and live are explicitly separated: backfill uses candle-only
    //    and (by design) uses mom/vol only to avoid fake OB/aggr proxies.
    // ============================================================

    // ----------------------------
    // Config
    // ----------------------------
    const SYMBOLS = ["BTCUSDT", "ETHUSDT"];

    // Fixed weights
    const WEIGHTS = {
      "BTCUSDT": 0.50,
      "ETHUSDT": 0.50,
    };

    // Live compute cadence (display updates)
    const LIVE_UPDATE_EVERY_MS = 5000;

    // Chart cadence: 1 point per minute
    const CHART_POINT_SECONDS = 60;

    // Basket EMA smoothing for live display
    const BASKET_ALPHA_LIVE = 0.10;

    // Backfill smoothing (default OFF for transparency)
    // You can toggle chart series between raw and smoothed.
    const ALPHA_BACKFILL = 0.10; // only used for "smoothed" backfill series

    // FGI core parameters (seconds)
    const P = {
      mom_short_s: 120,
      mom_long_s: 3600,
      vol_short_s: 240,
      vol_long_s: 3600,
      imb_window_s: 20,
      aggr_window_s: 1200,

      // NOTE: These are still heuristic. If your outputs stick near 50,
      // your k values are likely too large for realized returns/vol.
      k_m_short: 0.005,
      k_m_long: 0.02,
      k_v_short: 0.01,
      k_v_long: 0.02,

      mom_blend_short: 0.5,
      vol_blend_short: 0.5,

      // Live weights across components
      w_mom: 0.35,
      w_vol: 0.25,
      w_ob: 0.20,
      w_aggr: 0.20,

      // Backfill (candle-only) weights: USE ONLY mom/vol to avoid fake OB/aggr
      bf_w_mom: 0.60,
      bf_w_vol: 0.40,
    };

    const EPS = 1e-12;

    // ----------------------------
    // Helpers
    // ----------------------------
    function clamp(x, lo=0, hi=100) {
      x = Number(x);
      if (!Number.isFinite(x)) return lo;
      return Math.max(lo, Math.min(hi, x));
    }

    function tanhScoreSigned(x, k) {
      return clamp(50 + 50 * Math.tanh(x / (k + EPS)));
    }

    function tanhScoreNegative(x, k) {
      return clamp(50 + 50 * Math.tanh((-x) / (k + EPS)));
    }

    function std(arr) {
      const n = arr.length;
      if (n === 0) return 0;
      let mean = 0;
      for (const v of arr) mean += v;
      mean /= n;
      let ss = 0;
      for (const v of arr) {
        const d = v - mean;
        ss += d*d;
      }
      return Math.sqrt(ss / n);
    }

    function fmt(x, d=2) {
      if (x === null || x === undefined || !Number.isFinite(x)) return "--";
      return Number(x).toFixed(d);
    }

    function colorForFGI(v) {
      if (!Number.isFinite(v)) return "black";
      if (v >= 60) return "red";
      if (v <= 40) return "green";
      return "black";
    }

    function setConn(status) {
      const el = document.getElementById("conn");
      el.textContent = status;
      el.style.background = (status === "connected") ? "#eef9ee" : "#fff3f3";
      el.style.borderColor = (status === "connected") ? "#b8e0b8" : "#f0b5b5";
    }

    // ----------------------------
    // Binance REST backfill (1m klines)
    // ----------------------------
    async function fetchKlines(symbol, interval, startMs, endMs) {
      const url = new URL("https://api.binance.com/api/v3/klines");
      url.searchParams.set("symbol", symbol);
      url.searchParams.set("interval", interval);
      url.searchParams.set("startTime", String(startMs));
      url.searchParams.set("endTime", String(endMs));
      url.searchParams.set("limit", "1000");

      const res = await fetch(url.toString(), { method: "GET" });
      if (!res.ok) {
        const txt = await res.text().catch(() => "");
        throw new Error(`Klines fetch failed ${res.status}: ${txt}`);
      }
      return await res.json();
    }

    async function fetchLast24h1m(symbol) {
      const now = Date.now();
      const start = now - 24 * 3600 * 1000;

      // Up to 1440 points; API limit 1000, so do 2 chunks
      const mid = start + 1000 * 60 * 1000;

      const part1 = await fetchKlines(symbol, "1m", start, mid);
      const part2 = await fetchKlines(symbol, "1m", mid, now);

      // Merge + de-dup by openTime
      const map = new Map();
      for (const k of [...part1, ...part2]) map.set(k[0], k);
      const merged = Array.from(map.entries())
        .sort((a,b) => a[0] - b[0])
        .map(e => e[1]);

      return merged.filter(k => k[0] >= start && k[0] <= now);
    }

    // Binance kline format:
    // [
    //  0 openTime, 1 open, 2 high, 3 low, 4 close, 5 volume,
    //  6 closeTime, 7 quoteAssetVolume, 8 numberOfTrades,
    //  9 takerBuyBaseAssetVolume, 10 takerBuyQuoteAssetVolume, 11 ignore
    // ]
    function klinesToSeries(klines) {
      const t = [];
      const open = [];
      const high = [];
      const low = [];
      const close = [];
      const vol = [];

      for (const k of klines) {
        t.push(Math.floor(Number(k[0]) / 1000)); // seconds
        open.push(Number(k[1]));
        high.push(Number(k[2]));
        low.push(Number(k[3]));
        close.push(Number(k[4]));
        vol.push(Number(k[5]));
      }
      return { t, open, high, low, close, vol };
    }

    // Backfill: compute per-minute MOM + VOL only (no OB/aggr proxies)
    function computeAssetFrom1m_Backfill(series) {
      const { t, close } = series;
      const n = t.length;

      const ret = new Array(n).fill(NaN);
      for (let i=1; i<n; i++) {
        const p0 = close[i-1], p1 = close[i];
        if (p0 > 0 && p1 > 0) ret[i] = Math.log(p1 / (p0 + EPS));
      }

      const ms = Math.max(1, Math.round(P.mom_short_s / 60));
      const ml = Math.max(1, Math.round(P.mom_long_s / 60));
      const vs = Math.max(1, Math.round(P.vol_short_s / 60));
      const vl = Math.max(1, Math.round(P.vol_long_s / 60));

      const mom = new Array(n).fill(NaN);
      const volScore = new Array(n).fill(NaN);
      const asset = new Array(n).fill(NaN);

      for (let i=0; i<n; i++) {
        // Momentum short/long
        if (i - ms >= 0 && close[i-ms] > 0 && close[i] > 0) {
          const rS = Math.log(close[i] / (close[i-ms] + EPS));
          const momS = tanhScoreSigned(rS, P.k_m_short);

          let momVal = momS;
          if (i - ml >= 0 && close[i-ml] > 0) {
            const rL = Math.log(close[i] / (close[i-ml] + EPS));
            const momL = tanhScoreSigned(rL, P.k_m_long);
            const a = clamp(P.mom_blend_short, 0, 1);
            momVal = a * momS + (1 - a) * momL;
          }
          mom[i] = momVal;
        }

        // Volatility short/long (std of log returns)
        const retsS = [];
        for (let j=Math.max(1, i - vs + 1); j<=i; j++) if (Number.isFinite(ret[j])) retsS.push(ret[j]);
        const volS = std(retsS);
        const volSScore = tanhScoreNegative(volS, P.k_v_short);

        const retsL = [];
        for (let j=Math.max(1, i - vl + 1); j<=i; j++) if (Number.isFinite(ret[j])) retsL.push(ret[j]);
        const volL = retsL.length ? std(retsL) : volS;
        const volLScore = tanhScoreNegative(volL, P.k_v_long);

        const aV = clamp(P.vol_blend_short, 0, 1);
        volScore[i] = aV * volSScore + (1 - aV) * volLScore;

        if (Number.isFinite(mom[i])) {
          asset[i] = clamp(
            P.bf_w_mom * mom[i] +
            P.bf_w_vol * volScore[i]
          );
        }
      }

      return { t, close, mom, vol: volScore, asset };
    }

    // ----------------------------
    // Live WS state (for live per-asset table + current FGI)
    // ----------------------------
    class Rolling1s {
      constructor() { this.arr = []; } // {t, v}
      push(t, v) { this.arr.push({t, v}); }
      prune(cutoff) { while (this.arr.length && this.arr[0].t < cutoff) this.arr.shift(); }
      valuesSince(cutoff) { return this.arr.filter(x => x.t >= cutoff).map(x => x.v); }
      latest() { return this.arr.length ? this.arr[this.arr.length-1].v : null; }
    }

    class LiveSymbolState {
      constructor(symbol) {
        this.symbol = symbol;
        this.prices = new Rolling1s(); // per-second last price
        this.rets = new Rolling1s();   // per-second log returns
        this.buy1s = new Rolling1s();
        this.sell1s = new Rolling1s();
        this.imb = new Rolling1s();    // signed imbalance [-1,1] from depth10

        this.curSec = null;
        this.curPrice = null;
        this.curBuy = 0;
        this.curSell = 0;

        this._lastRetPrice = null;
      }

      keepSec() {
        return Math.max(P.mom_long_s, P.vol_long_s, P.aggr_window_s, P.imb_window_s, 600) + 60;
      }

      prune(nowSec) {
        const cutoff = nowSec - this.keepSec();
        this.prices.prune(cutoff);
        this.rets.prune(cutoff);
        this.buy1s.prune(cutoff);
        this.sell1s.prune(cutoff);
        this.imb.prune(nowSec - (P.imb_window_s + 120));
      }

      flushSecond(sec, price, buyQty, sellQty) {
        this.prices.push(sec, price);

        if (this._lastRetPrice != null && this._lastRetPrice > 0 && price > 0) {
          this.rets.push(sec, Math.log(price / (this._lastRetPrice + EPS)));
        }
        this._lastRetPrice = price;

        this.buy1s.push(sec, buyQty);
        this.sell1s.push(sec, sellQty);
      }

      onAggTrade(eventMs, price, qty, isBuyerMaker) {
        const sec = Math.floor(eventMs / 1000);
        price = Number(price);
        qty = Number(qty);

        if (this.curSec === null) {
          this.curSec = sec;
          this.curPrice = price;
          this.curBuy = 0;
          this.curSell = 0;
        }

        if (sec === this.curSec) {
          this.curPrice = price;
          if (isBuyerMaker) this.curSell += qty;
          else this.curBuy += qty;
          return;
        }

        this.flushSecond(this.curSec, Number(this.curPrice ?? price), this.curBuy, this.curSell);

        // fill small gaps (cap)
        const gap = sec - this.curSec;
        const fillMax = 30;
        if (gap > 1) {
          const lastP = Number(this.curPrice ?? price);
          const fillTo = Math.min(sec - 1, this.curSec + fillMax);
          for (let s=this.curSec + 1; s<=fillTo; s++) this.flushSecond(s, lastP, 0, 0);
        }

        this.curSec = sec;
        this.curPrice = price;
        this.curBuy = 0;
        this.curSell = 0;
        if (isBuyerMaker) this.curSell += qty;
        else this.curBuy += qty;

        this.prune(sec);
      }

      onDepth10(eventMs, bids, asks) {
        const sec = Math.floor(eventMs / 1000);
        let sumB = 0, sumA = 0;
        for (let i=0; i<Math.min(10, bids.length); i++) sumB += Number(bids[i][1]);
        for (let i=0; i<Math.min(10, asks.length); i++) sumA += Number(asks[i][1]);
        const imb = (sumB - sumA) / (sumB + sumA + EPS);
        this.imb.push(sec, imb);
        this.prune(sec);
      }

      priceAtOrAfter(targetSec) {
        for (const x of this.prices.arr) {
          if (x.t >= targetSec) return x.v;
        }
        return null;
      }

      compute(nowSec) {
        this.prune(nowSec);

        const pNow = this.prices.latest();
        if (!(pNow > 0)) return null;

        const pS = this.priceAtOrAfter(nowSec - P.mom_short_s);
        if (!(pS > 0)) return null;

        const rS = Math.log(pNow / (pS + EPS));
        const momS = tanhScoreSigned(rS, P.k_m_short);

        let mom = momS;
        const pL = this.priceAtOrAfter(nowSec - P.mom_long_s);
        if (pL && pL > 0) {
          const rL = Math.log(pNow / (pL + EPS));
          const momL = tanhScoreSigned(rL, P.k_m_long);
          const a = clamp(P.mom_blend_short, 0, 1);
          mom = a * momS + (1 - a) * momL;
        }

        const retsS = this.rets.valuesSince(nowSec - P.vol_short_s);
        const volS = std(retsS);
        const volSScore = tanhScoreNegative(volS, P.k_v_short);

        const retsL = this.rets.valuesSince(nowSec - P.vol_long_s);
        const volL = retsL.length ? std(retsL) : volS;
        const volLScore = tanhScoreNegative(volL, P.k_v_long);

        const aV = clamp(P.vol_blend_short, 0, 1);
        const vol = aV * volSScore + (1 - aV) * volLScore;

        const imbs = this.imb.valuesSince(nowSec - P.imb_window_s);
        let ob = 50;
        if (imbs.length) {
          const mean = imbs.reduce((a,b)=>a+b,0) / imbs.length;
          ob = clamp(50 + 50 * mean);
        }

        const buys = this.buy1s.valuesSince(nowSec - P.aggr_window_s);
        const sells = this.sell1s.valuesSince(nowSec - P.aggr_window_s);
        const bSum = buys.reduce((a,b)=>a+b,0);
        const sSum = sells.reduce((a,b)=>a+b,0);
        const aggr = (bSum + sSum > 0) ? clamp(100 * (bSum / (bSum + sSum + EPS))) : 50;

        const asset = clamp(
          P.w_mom * mom +
          P.w_vol * vol +
          P.w_ob  * ob +
          P.w_aggr * aggr
        );

        return { symbol: this.symbol, t_sec: nowSec, price: pNow, mom, vol, ob, aggr, asset };
      }
    }

    const liveStates = {};
    for (const s of SYMBOLS) liveStates[s] = new LiveSymbolState(s);

    // ----------------------------
    // Chart
    // ----------------------------
    let chart = null;
    function initChart() {
      const ctx = document.getElementById("chart").getContext("2d");
      chart = new Chart(ctx, {
        type: "line",
        data: {
          labels: [],
          datasets: [{
            label: "FGI (1/min)",
            data: [],
            borderWidth: 2,
            pointRadius: 0,
            tension: 0.25
          }]
        },
        options: {
          responsive: true,
          animation: false,
          scales: { y: { min: 0, max: 100 } }
        }
      });
    }

    // ----------------------------
    // Backfill cache + recompute
    // ----------------------------
    let backfillCache = null;   // { commonT, idx, bySym }
    let backfillSeriesRaw = [];      // [{t_sec,fgi_raw}]  (no smoothing)
    let backfillSeriesSmoothed = []; // [{t_sec,fgi,fgi_raw}] (EMA on top of raw)
    let prevBasketLive = 50.0;
    let lastChartMinute = null;

    // UI state: which series is displayed, and which series is used for stats
    let chartMode = "raw";   // "raw" or "smoothed"
    let statsMode = "raw";   // "raw" or "smoothed"

    function setSeriesStatus() {
      document.getElementById("seriesStatus").textContent = `Chart: ${chartMode}`;
      document.getElementById("statsStatus").textContent = `Stats: ${statsMode}`;
    }

    async function loadBackfillCacheOnce() {
      const el = document.getElementById("backfill");
      el.textContent = "Backfill: starting 24h fetch…";

      const bySym = {};
      for (const sym of SYMBOLS) {
        el.textContent = `Backfill: fetching ${sym}…`;
        const kl = await fetchLast24h1m(sym);
        bySym[sym] = computeAssetFrom1m_Backfill(klinesToSeries(kl));
      }

      // Align on common minutes
      const ref = bySym[SYMBOLS[0]].t;
      const has = {};
      for (const sym of SYMBOLS) has[sym] = new Set(bySym[sym].t);

      const commonT = ref.filter(ts => SYMBOLS.every(sym => has[sym].has(ts)));
      if (!commonT.length) {
        el.textContent = "Backfill: no overlapping timestamps across symbols (check REST access).";
        backfillCache = null;
        return;
      }

      const idx = {};
      for (const sym of SYMBOLS) {
        idx[sym] = new Map();
        bySym[sym].t.forEach((ts, i) => idx[sym].set(ts, i));
      }

      backfillCache = { commonT, idx, bySym };
      el.textContent = `Backfill: cache ready (${commonT.length} minutes). Rendering…`;

      recomputeBackfillFromCache();
    }

    function recomputeBackfillFromCache() {
      const el = document.getElementById("backfill");
      if (!backfillCache) {
        el.textContent = "Backfill: cache not ready.";
        return;
      }

      const { commonT, idx, bySym } = backfillCache;

      // Raw series (no smoothing)
      const rawOut = [];
      for (const ts of commonT) {
        let total = 0;
        let used = 0;

        for (const sym of SYMBOLS) {
          const i = idx[sym].get(ts);
          const a = bySym[sym].asset[i];
          const w = Number(WEIGHTS[sym] || 0);
          if (Number.isFinite(a) && w > 0) {
            total += w * a;
            used += w;
          }
        }
        if (used <= 0) continue;

        const fgiRaw = clamp(total / (used + EPS));
        rawOut.push({ t_sec: ts, fgi_raw: fgiRaw });
      }
      backfillSeriesRaw = rawOut;

      // Smoothed series (EMA applied to raw)
      const smoothOut = [];
      let prev = 50.0;
      for (const p of backfillSeriesRaw) {
        const fgi = clamp(ALPHA_BACKFILL * p.fgi_raw + (1 - ALPHA_BACKFILL) * prev);
        prev = fgi;
        smoothOut.push({ t_sec: p.t_sec, fgi_raw: p.fgi_raw, fgi });
      }
      backfillSeriesSmoothed = smoothOut;

      // Seed live EMA from latest BACKFILL RAW (not smoothed) to reduce drift-to-50 from smoothing chains
      // (Still smooth live display using BASKET_ALPHA_LIVE.)
      if (backfillSeriesRaw.length) prevBasketLive = backfillSeriesRaw[backfillSeriesRaw.length - 1].fgi_raw;

      // Render chart
      renderChartFromMode();

      el.textContent = `Backfill: rendered ${Math.min(24*60, backfillSeriesRaw.length)} pts (raw + optional smoothing).`;
    }

    function renderChartFromMode() {
      const maxPts = 24 * 60;
      const series = (chartMode === "smoothed") ? backfillSeriesSmoothed : backfillSeriesRaw;

      const slice = series.slice(-maxPts);

      chart.data.labels = [];
      chart.data.datasets[0].data = [];

      for (const p of slice) {
        chart.data.labels.push(new Date(p.t_sec * 1000).toLocaleTimeString());
        chart.data.datasets[0].data.push(chartMode === "smoothed" ? p.fgi : p.fgi_raw);
      }

      chart.update("none");
      update24hStats();
      setSeriesStatus();
    }

    function update24hStats() {
      const maxPts = 24 * 60;
      const series = (statsMode === "smoothed") ? backfillSeriesSmoothed : backfillSeriesRaw;
      const slice = series.slice(-maxPts);

      if (!slice.length) {
        document.getElementById("stats").textContent = "";
        return;
      }

      let hi = -Infinity, lo = Infinity, sum = 0, n = 0;
      for (const p of slice) {
        const v = (statsMode === "smoothed") ? p.fgi : p.fgi_raw;
        const x = Number(v);
        if (!Number.isFinite(x)) continue;
        if (x > hi) hi = x;
        if (x < lo) lo = x;
        sum += x; n++;
      }
      if (!n) return;
      const avg = sum / n;

      document.getElementById("stats").textContent =
        `24h (${statsMode}) FGI: high=${hi.toFixed(2)}  low=${lo.toFixed(2)}  avg=${avg.toFixed(2)}  (points=${n})`;
    }

    // ----------------------------
    // Live WebSocket
    // ----------------------------
    let ws = null;
    let wsBackoffMs = 500;

    function connectWS() {
      const streams = [];
      for (const sym of SYMBOLS) {
        const s = sym.toLowerCase();
        streams.push(`${s}@aggTrade`);
        streams.push(`${s}@depth10@100ms`);
      }
      const url = `wss://stream.binance.com:9443/stream?streams=${streams.join("/")}`;
      ws = new WebSocket(url);

      ws.onopen = () => { setConn("connected"); wsBackoffMs = 500; };
      ws.onclose = () => {
        setConn("disconnected");
        setTimeout(connectWS, wsBackoffMs);
        wsBackoffMs = Math.min(15000, wsBackoffMs * 1.5);
      };
      ws.onerror = () => { try { ws.close(); } catch {} };

      ws.onmessage = (ev) => {
        let msg;
        try { msg = JSON.parse(ev.data); } catch { return; }
        const stream = msg.stream || "";
        const d = msg.data || {};

        const sym = stream.split("@")[0].toUpperCase();
        if (!liveStates[sym]) return;

        if (stream.endsWith("@aggTrade")) {
          liveStates[sym].onAggTrade(Number(d.E), Number(d.p), Number(d.q), Boolean(d.m));
          return;
        }
        if (stream.includes("@depth10")) {
          liveStates[sym].onDepth10(Number(d.E), d.b || [], d.a || []);
          return;
        }
      };
    }

    // ----------------------------
    // Live compute + UI
    // ----------------------------
    function updateTable(snapshotAssets) {
      const rows = document.getElementById("rows");
      rows.innerHTML = "";
      const keys = Object.keys(snapshotAssets).sort();
      for (const k of keys) {
        const a = snapshotAssets[k];
        const tr = document.createElement("tr");
        tr.innerHTML =
          `<td>${k}</td>` +
          `<td>${fmt(a.price, 2)}</td>` +
          `<td>${fmt(a.asset, 2)}</td>` +
          `<td>${fmt(a.mom, 2)}</td>` +
          `<td>${fmt(a.vol, 2)}</td>` +
          `<td>${fmt(a.ob, 2)}</td>` +
          `<td>${fmt(a.aggr, 2)}</td>`;
        rows.appendChild(tr);
      }
    }

    function computeLiveOnce() {
      const nowSec = Math.floor(Date.now() / 1000);

      const assets = {};
      let total = 0;
      let used = 0;

      for (const sym of SYMBOLS) {
        const sc = liveStates[sym].compute(nowSec);
        if (!sc) continue;
        assets[sym] = sc;

        const w = Number(WEIGHTS[sym] || 0);
        if (w > 0) {
          total += w * sc.asset;
          used += w;
        }
      }

      if (used <= 0) return null;

      const fgiRaw = clamp(total / (used + EPS));
      const fgi = clamp(BASKET_ALPHA_LIVE * fgiRaw + (1 - BASKET_ALPHA_LIVE) * prevBasketLive);
      prevBasketLive = fgi;

      return { t_sec: nowSec, fgi_raw: fgiRaw, fgi, assets };
    }

    function updateHeader(snap) {
      const fgiEl = document.getElementById("fgi");
      fgiEl.textContent = fmt(snap.fgi, 2);
      fgiEl.style.color = colorForFGI(snap.fgi);

      const dt = new Date(snap.t_sec * 1000);
      document.getElementById("meta").textContent =
        `live raw=${fmt(snap.fgi_raw,2)} | ${dt.toLocaleString()} | alpha=${BASKET_ALPHA_LIVE} | weights: BTC=50% ETH=50%`;
    }

    function maybeAppendChartPoint(snap) {
      // Append at minute boundaries only
      const minute = Math.floor(snap.t_sec / CHART_POINT_SECONDS);
      if (lastChartMinute === null) lastChartMinute = minute;

      if (minute !== lastChartMinute) {
        lastChartMinute = minute;

        // Append live point to whichever chart mode is active (raw or smoothed)
        const label = new Date(snap.t_sec * 1000).toLocaleTimeString();

        chart.data.labels.push(label);
        chart.data.datasets[0].data.push(chartMode === "smoothed" ? snap.fgi : snap.fgi_raw);

        // Keep last 24h in chart (1440 points)
        const maxPts = 24 * 60;
        while (chart.data.labels.length > maxPts) {
          chart.data.labels.shift();
          chart.data.datasets[0].data.shift();
        }

        chart.update("none");

        // Stats: recompute from backfill cache + current series mode
        // (For simplicity we update stats from chart dataset, which is now mode-consistent.)
        // If you want stats strictly from backfill-only, call update24hStats() instead.
        update24hStats();
      }
    }

    // ----------------------------
    // UI wiring (raw/smoothed toggles)
    // ----------------------------
    function initSeriesUI() {
      setSeriesStatus();

      document.getElementById("btnShowRaw").onclick = () => {
        chartMode = "raw";
        renderChartFromMode();
      };
      document.getElementById("btnShowSmoothed").onclick = () => {
        chartMode = "smoothed";
        renderChartFromMode();
      };

      document.getElementById("btnStatsRaw").onclick = () => {
        statsMode = "raw";
        update24hStats();
        setSeriesStatus();
      };
      document.getElementById("btnStatsSmoothed").onclick = () => {
        statsMode = "smoothed";
        update24hStats();
        setSeriesStatus();
      };
    }

    // ----------------------------
    // Boot
    // ----------------------------
    (async () => {
      // lock UI weights (reflect fixed 50/50)
      document.getElementById("w_BTCUSDT").value = "0.50";
      document.getElementById("w_ETHUSDT").value = "0.50";

      initChart();
      initSeriesUI();
      setConn("disconnected");

      try {
        await loadBackfillCacheOnce();
      } catch (e) {
        document.getElementById("backfill").textContent =
          `Backfill failed: ${String(e.message || e)}`;
      }

      connectWS();

      setInterval(() => {
        const snap = computeLiveOnce();
        if (!snap) return;

        updateHeader(snap);
        updateTable(snap.assets);
        maybeAppendChartPoint(snap);
      }, LIVE_UPDATE_EVERY_MS);
    })();
  </script>
</body>
</html>
