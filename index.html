<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Live Crypto FGI (24h Backfill, No Storage)</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 16px; }
    .card { border: 1px solid #ddd; border-radius: 12px; padding: 12px; margin-bottom: 12px; }
    .big { font-size: 44px; font-weight: 700; }
    .muted { color: #666; }
    .row { display:flex; gap:12px; flex-wrap:wrap; }
    .col { flex:1 1 220px; }
    table { width: 100%; border-collapse: collapse; }
    th, td { text-align: left; padding: 8px; border-bottom: 1px solid #eee; font-size: 14px; }
    .pill { display:inline-block; padding:2px 8px; border-radius:999px; border:1px solid #ddd; font-size:12px; }
    canvas { width: 100%; max-height: 320px; }
    .small { font-size: 12px; }
    code { background:#f7f7f7; padding:2px 4px; border-radius:6px; }
    .warn { color: #8a5a00; }
    input[type="number"] { width: 110px; padding: 6px; border: 1px solid #ddd; border-radius: 8px; }
    button { padding: 8px 10px; border-radius: 10px; border: 1px solid #ddd; background: #f7f7f7; cursor: pointer; }
    button:hover { background: #efefef; }
    .err { color: #a40000; }
  </style>
</head>
<body>

  <div class="card">
    <div class="row">
      <div class="col">
        <div class="muted">Basket FGI (live updates every 5s; chart is 1/min)</div>
        <div id="fgi" class="big">--</div>
        <div id="meta" class="muted small"></div>
        <div id="stats" class="muted small"></div>
        <div id="backfill" class="muted small"></div>
        <div class="small warn" style="margin-top:6px;">
          Note: historical order book isn’t available from Binance; OB uses a candle-based proxy for the 24h backfill.
        </div>
      </div>
      <div class="col">
        <div class="muted">Connection</div>
        <div id="conn" class="pill">disconnected</div>
        <div class="muted small" style="margin-top:8px;">
          REST backfill: <code>/api/v3/klines</code> (1m)<br/>
          Live: <code>aggTrade</code> + <code>depth10</code>
        </div>
      </div>
    </div>
  </div>

  <!-- NEW: Weights UI -->
  <div class="card">
    <div class="muted">Basket weights (auto-normalized to sum to 1)</div>
    <div class="row" style="margin-top:10px;">
      <div class="col">
        <div class="small muted">BTCUSDT</div>
        <input id="w_BTCUSDT" type="number" step="0.01" min="0" value="0.25"/>
      </div>
      <div class="col">
        <div class="small muted">ETHUSDT</div>
        <input id="w_ETHUSDT" type="number" step="0.01" min="0" value="0.25"/>
      </div>
      <div class="col">
        <div class="small muted">XRPUSDT</div>
        <input id="w_XRPUSDT" type="number" step="0.01" min="0" value="0.25"/>
      </div>
      <div class="col">
        <div class="small muted">SOLUSDT</div>
        <input id="w_SOLUSDT" type="number" step="0.01" min="0" value="0.25"/>
      </div>
    </div>

    <div class="row" style="margin-top:10px; align-items:center;">
      <button id="btnNormalize" type="button">Normalize</button>
      <button id="btnApply" type="button">Apply (recompute 24h + live)</button>
      <span id="wStatus" class="small muted"></span>
      <span id="wError" class="small err"></span>
    </div>
    <div class="small muted" style="margin-top:6px;">
      Tip: you can enter any non-negative numbers. They will be normalized (e.g., 2/1/1/0 becomes 0.5/0.25/0.25/0).
    </div>
  </div>

  <div class="card">
    <div class="muted">FGI history (last 24h, 1 point/min)</div>
    <canvas id="chart"></canvas>
  </div>

  <div class="card">
    <div class="muted">Per-asset components (live, computed from WS)</div>
    <table>
      <thead>
        <tr>
          <th>Symbol</th><th>Price</th><th>Asset</th><th>Mom</th><th>Vol</th><th>OB</th><th>Agg</th>
        </tr>
      </thead>
      <tbody id="rows"></tbody>
    </table>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script>
    // ----------------------------
    // Config
    // ----------------------------
    const SYMBOLS = ["BTCUSDT", "ETHUSDT", "XRPUSDT", "SOLUSDT"];

    // Basket weights (runtime mutable)
    let WEIGHTS = {
      "BTCUSDT": 0.25,
      "ETHUSDT": 0.25,
      "XRPUSDT": 0.25,
      "SOLUSDT": 0.25,
    };

    const LIVE_UPDATE_EVERY_MS = 5000;
    const CHART_POINT_SECONDS = 60;
    const BASKET_ALPHA_LIVE = 0.10;

    // Backfill smoothing (set to 0.10 if you want it identical to live)
    const ALPHA_BACKFILL = 0.10;

    // FGI core parameters (seconds)
    const P = {
      mom_short_s: 120,
      mom_long_s: 3600,
      vol_short_s: 240,
      vol_long_s: 3600,
      imb_window_s: 20,
      aggr_window_s: 1200,

      k_m_short: 0.005,
      k_m_long: 0.02,
      k_v_short: 0.01,
      k_v_long: 0.02,

      mom_blend_short: 0.5,
      vol_blend_short: 0.5,

      w_mom: 0.35,
      w_vol: 0.25,
      w_ob: 0.20,
      w_aggr: 0.20,
    };

    const EPS = 1e-12;

    // ----------------------------
    // Helpers
    // ----------------------------
    function clamp(x, lo=0, hi=100) {
      x = Number(x);
      if (!Number.isFinite(x)) return lo;
      return Math.max(lo, Math.min(hi, x));
    }

    function tanhScoreSigned(x, k) {
      return clamp(50 + 50 * Math.tanh(x / (k + EPS)));
    }

    function tanhScoreNegative(x, k) {
      return clamp(50 + 50 * Math.tanh((-x) / (k + EPS)));
    }

    function std(arr) {
      const n = arr.length;
      if (n === 0) return 0;
      let mean = 0;
      for (const v of arr) mean += v;
      mean /= n;
      let ss = 0;
      for (const v of arr) {
        const d = v - mean;
        ss += d*d;
      }
      return Math.sqrt(ss / n);
    }

    function fmt(x, d=2) {
      if (x === null || x === undefined || !Number.isFinite(x)) return "--";
      return Number(x).toFixed(d);
    }

    function colorForFGI(v) {
      if (!Number.isFinite(v)) return "black";
      if (v >= 60) return "red";
      if (v <= 40) return "green";
      return "black";
    }

    function setConn(status) {
      const el = document.getElementById("conn");
      el.textContent = status;
      el.style.background = (status === "connected") ? "#eef9ee" : "#fff3f3";
      el.style.borderColor = (status === "connected") ? "#b8e0b8" : "#f0b5b5";
    }

    function update24hStatsFromChart() {
      if (!chart) return;
      const data = chart.data.datasets[0].data || [];
      if (!data.length) {
        document.getElementById("stats").textContent = "";
        return;
      }

      let hi = -Infinity, lo = Infinity, sum = 0, n = 0;
      for (const v of data) {
        const x = Number(v);
        if (!Number.isFinite(x)) continue;
        if (x > hi) hi = x;
        if (x < lo) lo = x;
        sum += x;
        n++;
      }
      if (!n) return;

      const avg = sum / n;
      document.getElementById("stats").textContent =
        `24h FGI: high=${hi.toFixed(2)}  low=${lo.toFixed(2)}  avg=${avg.toFixed(2)}  (points=${n})`;
    }

    function normalizeWeights(obj) {
      // clamp invalids to 0
      const clean = {};
      let sum = 0;
      for (const sym of SYMBOLS) {
        const v = Number(obj[sym]);
        const w = (Number.isFinite(v) && v > 0) ? v : 0;
        clean[sym] = w;
        sum += w;
      }
      if (sum <= 0) return { ok: false, weights: null, msg: "Weights sum to 0. Enter at least one positive weight." };
      for (const sym of SYMBOLS) clean[sym] = clean[sym] / sum;
      return { ok: true, weights: clean, msg: `Normalized (sum=1).` };
    }

    function readWeightsFromUI() {
      const w = {};
      for (const sym of SYMBOLS) {
        const el = document.getElementById(`w_${sym}`);
        w[sym] = Number(el.value);
      }
      return w;
    }

    function writeWeightsToUI(w) {
      for (const sym of SYMBOLS) {
        const el = document.getElementById(`w_${sym}`);
        el.value = (Number(w[sym]) || 0).toFixed(4);
      }
    }

    function setWeightStatus(msg, isError=false) {
      document.getElementById("wStatus").textContent = isError ? "" : msg;
      document.getElementById("wError").textContent = isError ? msg : "";
    }

    // ----------------------------
    // Binance REST backfill (1m klines)
    // ----------------------------
    async function fetchKlines(symbol, interval, startMs, endMs) {
      const url = new URL("https://api.binance.com/api/v3/klines");
      url.searchParams.set("symbol", symbol);
      url.searchParams.set("interval", interval);
      url.searchParams.set("startTime", String(startMs));
      url.searchParams.set("endTime", String(endMs));
      url.searchParams.set("limit", "1000");

      const res = await fetch(url.toString(), { method: "GET" });
      if (!res.ok) {
        const txt = await res.text().catch(() => "");
        throw new Error(`Klines fetch failed ${res.status}: ${txt}`);
      }
      return await res.json();
    }

    async function fetchLast24h1m(symbol) {
      const now = Date.now();
      const start = now - 24 * 3600 * 1000;
      const mid = start + 1000 * 60 * 1000;

      const part1 = await fetchKlines(symbol, "1m", start, mid);
      const part2 = await fetchKlines(symbol, "1m", mid, now);

      const map = new Map();
      for (const k of [...part1, ...part2]) map.set(k[0], k);
      const merged = Array.from(map.entries())
        .sort((a,b) => a[0] - b[0])
        .map(e => e[1]);

      return merged.filter(k => k[0] >= start && k[0] <= now);
    }

    function klinesToSeries(klines) {
      const t = [];
      const open = [];
      const high = [];
      const low = [];
      const close = [];
      const vol = [];
      const takerBuy = [];

      for (const k of klines) {
        t.push(Math.floor(Number(k[0]) / 1000));
        open.push(Number(k[1]));
        high.push(Number(k[2]));
        low.push(Number(k[3]));
        close.push(Number(k[4]));
        vol.push(Number(k[5]));
        takerBuy.push(Number(k[9]));
      }
      return { t, open, high, low, close, vol, takerBuy };
    }

    function computeAssetFrom1m(series) {
      const { t, open, high, low, close, vol, takerBuy } = series;
      const n = t.length;

      const ret = new Array(n).fill(NaN);
      for (let i=1; i<n; i++) {
        const p0 = close[i-1], p1 = close[i];
        if (p0 > 0 && p1 > 0) ret[i] = Math.log(p1 / (p0 + EPS));
      }

      const ms = Math.max(1, Math.round(P.mom_short_s / 60));
      const ml = Math.max(1, Math.round(P.mom_long_s / 60));
      const vs = Math.max(1, Math.round(P.vol_short_s / 60));
      const vl = Math.max(1, Math.round(P.vol_long_s / 60));
      const iw = Math.max(1, Math.round(P.imb_window_s / 60));
      const aw = Math.max(1, Math.round(P.aggr_window_s / 60));

      const mom = new Array(n).fill(NaN);
      const volScore = new Array(n).fill(NaN);
      const ob = new Array(n).fill(NaN);
      const aggr = new Array(n).fill(NaN);
      const asset = new Array(n).fill(NaN);

      const imbProxy = new Array(n).fill(0);
      for (let i=0; i<n; i++) {
        const rng = (high[i] - low[i]);
        if (rng > 0) imbProxy[i] = Math.max(-1, Math.min(1, (close[i] - open[i]) / (rng + EPS)));
        else imbProxy[i] = 0;
      }

      for (let i=0; i<n; i++) {
        if (i - ms >= 0 && close[i-ms] > 0 && close[i] > 0) {
          const rS = Math.log(close[i] / (close[i-ms] + EPS));
          const momS = tanhScoreSigned(rS, P.k_m_short);

          let momVal = momS;
          if (i - ml >= 0 && close[i-ml] > 0) {
            const rL = Math.log(close[i] / (close[i-ml] + EPS));
            const momL = tanhScoreSigned(rL, P.k_m_long);
            const a = clamp(P.mom_blend_short, 0, 1);
            momVal = a * momS + (1 - a) * momL;
          }
          mom[i] = momVal;
        }

        const retsS = [];
        for (let j=Math.max(1, i - vs + 1); j<=i; j++) if (Number.isFinite(ret[j])) retsS.push(ret[j]);
        const volS = std(retsS);
        const volSScore = tanhScoreNegative(volS, P.k_v_short);

        const retsL = [];
        for (let j=Math.max(1, i - vl + 1); j<=i; j++) if (Number.isFinite(ret[j])) retsL.push(ret[j]);
        const volL = retsL.length ? std(retsL) : volS;
        const volLScore = tanhScoreNegative(volL, P.k_v_long);

        const aV = clamp(P.vol_blend_short, 0, 1);
        volScore[i] = aV * volSScore + (1 - aV) * volLScore;

        let sumImb = 0, cntImb = 0;
        for (let j=Math.max(0, i - iw + 1); j<=i; j++) { sumImb += imbProxy[j]; cntImb++; }
        ob[i] = clamp(50 + 50 * (cntImb ? (sumImb / cntImb) : 0));

        let bSum = 0, vSum = 0;
        for (let j=Math.max(0, i - aw + 1); j<=i; j++) {
          bSum += takerBuy[j];
          vSum += vol[j];
        }
        aggr[i] = (vSum > 0) ? clamp(100 * (bSum / (vSum + EPS))) : 50;

        if (Number.isFinite(mom[i])) {
          asset[i] = clamp(
            P.w_mom * mom[i] +
            P.w_vol * volScore[i] +
            P.w_ob  * ob[i] +
            P.w_aggr * aggr[i]
          );
        }
      }

      return { t, close, mom, vol: volScore, ob, aggr, asset };
    }

    // ----------------------------
    // Live WS state
    // ----------------------------
    class Rolling1s {
      constructor() { this.arr = []; }
      push(t, v) { this.arr.push({t, v}); }
      prune(cutoff) { while (this.arr.length && this.arr[0].t < cutoff) this.arr.shift(); }
      valuesSince(cutoff) { return this.arr.filter(x => x.t >= cutoff).map(x => x.v); }
      latest() { return this.arr.length ? this.arr[this.arr.length-1].v : null; }
    }

    class LiveSymbolState {
      constructor(symbol) {
        this.symbol = symbol;
        this.prices = new Rolling1s();
        this.rets = new Rolling1s();
        this.buy1s = new Rolling1s();
        this.sell1s = new Rolling1s();
        this.imb = new Rolling1s();

        this.curSec = null;
        this.curPrice = null;
        this.curBuy = 0;
        this.curSell = 0;

        this._lastRetPrice = null;
      }

      keepSec() {
        return Math.max(P.mom_long_s, P.vol_long_s, P.aggr_window_s, P.imb_window_s, 600) + 60;
      }

      prune(nowSec) {
        const cutoff = nowSec - this.keepSec();
        this.prices.prune(cutoff);
        this.rets.prune(cutoff);
        this.buy1s.prune(cutoff);
        this.sell1s.prune(cutoff);
        this.imb.prune(nowSec - (P.imb_window_s + 120));
      }

      flushSecond(sec, price, buyQty, sellQty) {
        this.prices.push(sec, price);

        if (this._lastRetPrice != null && this._lastRetPrice > 0 && price > 0) {
          this.rets.push(sec, Math.log(price / (this._lastRetPrice + EPS)));
        }
        this._lastRetPrice = price;

        this.buy1s.push(sec, buyQty);
        this.sell1s.push(sec, sellQty);
      }

      onAggTrade(eventMs, price, qty, isBuyerMaker) {
        const sec = Math.floor(eventMs / 1000);
        price = Number(price);
        qty = Number(qty);

        if (this.curSec === null) {
          this.curSec = sec;
          this.curPrice = price;
          this.curBuy = 0;
          this.curSell = 0;
        }

        if (sec === this.curSec) {
          this.curPrice = price;
          if (isBuyerMaker) this.curSell += qty;
          else this.curBuy += qty;
          return;
        }

        this.flushSecond(this.curSec, Number(this.curPrice ?? price), this.curBuy, this.curSell);

        const gap = sec - this.curSec;
        const fillMax = 30;
        if (gap > 1) {
          const lastP = Number(this.curPrice ?? price);
          const fillTo = Math.min(sec - 1, this.curSec + fillMax);
          for (let s=this.curSec + 1; s<=fillTo; s++) this.flushSecond(s, lastP, 0, 0);
        }

        this.curSec = sec;
        this.curPrice = price;
        this.curBuy = 0;
        this.curSell = 0;
        if (isBuyerMaker) this.curSell += qty;
        else this.curBuy += qty;

        this.prune(sec);
      }

      onDepth10(eventMs, bids, asks) {
        const sec = Math.floor(eventMs / 1000);
        let sumB = 0, sumA = 0;
        for (let i=0; i<Math.min(10, bids.length); i++) sumB += Number(bids[i][1]);
        for (let i=0; i<Math.min(10, asks.length); i++) sumA += Number(asks[i][1]);
        const imb = (sumB - sumA) / (sumB + sumA + EPS);
        this.imb.push(sec, imb);
        this.prune(sec);
      }

      priceAtOrAfter(targetSec) {
        for (const x of this.prices.arr) {
          if (x.t >= targetSec) return x.v;
        }
        return null;
      }

      compute(nowSec) {
        this.prune(nowSec);

        const pNow = this.prices.latest();
        if (!(pNow > 0)) return null;

        const pS = this.priceAtOrAfter(nowSec - P.mom_short_s);
        if (!(pS > 0)) return null;

        const rS = Math.log(pNow / (pS + EPS));
        const momS = tanhScoreSigned(rS, P.k_m_short);

        let mom = momS;
        const pL = this.priceAtOrAfter(nowSec - P.mom_long_s);
        if (pL && pL > 0) {
          const rL = Math.log(pNow / (pL + EPS));
          const momL = tanhScoreSigned(rL, P.k_m_long);
          const a = clamp(P.mom_blend_short, 0, 1);
          mom = a * momS + (1 - a) * momL;
        }

        const retsS = this.rets.valuesSince(nowSec - P.vol_short_s);
        const volS = std(retsS);
        const volSScore = tanhScoreNegative(volS, P.k_v_short);

        const retsL = this.rets.valuesSince(nowSec - P.vol_long_s);
        const volL = retsL.length ? std(retsL) : volS;
        const volLScore = tanhScoreNegative(volL, P.k_v_long);

        const aV = clamp(P.vol_blend_short, 0, 1);
        const vol = aV * volSScore + (1 - aV) * volLScore;

        const imbs = this.imb.valuesSince(nowSec - P.imb_window_s);
        let ob = 50;
        if (imbs.length) {
          const mean = imbs.reduce((a,b)=>a+b,0) / imbs.length;
          ob = clamp(50 + 50 * mean);
        }

        const buys = this.buy1s.valuesSince(nowSec - P.aggr_window_s);
        const sells = this.sell1s.valuesSince(nowSec - P.aggr_window_s);
        const bSum = buys.reduce((a,b)=>a+b,0);
        const sSum = sells.reduce((a,b)=>a+b,0);
        const aggr = (bSum + sSum > 0) ? clamp(100 * (bSum / (bSum + sSum + EPS))) : 50;

        const asset = clamp(
          P.w_mom * mom +
          P.w_vol * vol +
          P.w_ob  * ob +
          P.w_aggr * aggr
        );

        return { symbol: this.symbol, t_sec: nowSec, price: pNow, mom, vol, ob, aggr, asset };
      }
    }

    const liveStates = {};
    for (const s of SYMBOLS) liveStates[s] = new LiveSymbolState(s);

    // ----------------------------
    // Chart
    // ----------------------------
    let chart = null;
    function initChart() {
      const ctx = document.getElementById("chart").getContext("2d");
      chart = new Chart(ctx, {
        type: "line",
        data: {
          labels: [],
          datasets: [{
            label: "FGI (1/min)",
            data: [],
            borderWidth: 2,
            pointRadius: 0,
            tension: 0.25
          }]
        },
        options: {
          responsive: true,
          animation: false,
          scales: { y: { min: 0, max: 100 } }
        }
      });
    }

    // ----------------------------
    // Backfill (24h) – recomputable when weights change
    // ----------------------------
    let backfillSeries = [];
    let prevBasketLive = 50.0;
    let lastChartMinute = null;

    async function runBackfill() {
      const el = document.getElementById("backfill");
      el.textContent = "Backfill: starting 24h fetch…";

      const bySym = {};
      for (const sym of SYMBOLS) {
        el.textContent = `Backfill: fetching ${sym}…`;
        const kl = await fetchLast24h1m(sym);
        bySym[sym] = computeAssetFrom1m(klinesToSeries(kl));
      }

      const ref = bySym[SYMBOLS[0]].t;
      const has = {};
      for (const sym of SYMBOLS) has[sym] = new Set(bySym[sym].t);

      const commonT = ref.filter(ts => SYMBOLS.every(sym => has[sym].has(ts)));
      if (!commonT.length) {
        el.textContent = "Backfill: no overlapping timestamps across symbols (check REST access).";
        return;
      }

      const idx = {};
      for (const sym of SYMBOLS) {
        idx[sym] = new Map();
        bySym[sym].t.forEach((ts, i) => idx[sym].set(ts, i));
      }

      const out = [];
      let prev = 50.0;

      for (const ts of commonT) {
        let total = 0;
        let used = 0;

        for (const sym of SYMBOLS) {
          const i = idx[sym].get(ts);
          const a = bySym[sym].asset[i];
          const w = Number(WEIGHTS[sym] || 0);
          if (Number.isFinite(a) && w > 0) {
            total += w * a;
            used += w;
          }
        }

        if (used <= 0) continue;

        const fgiRaw = clamp(total / (used + EPS));
        const fgi = clamp(ALPHA_BACKFILL * fgiRaw + (1 - ALPHA_BACKFILL) * prev);
        prev = fgi;

        out.push({ t_sec: ts, fgi_raw: fgiRaw, fgi });
      }

      backfillSeries = out;

      chart.data.labels = [];
      chart.data.datasets[0].data = [];
      const maxPts = 24 * 60;
      const slice = backfillSeries.slice(-maxPts);

      for (const p of slice) {
        chart.data.labels.push(new Date(p.t_sec * 1000).toLocaleTimeString());
        chart.data.datasets[0].data.push(p.fgi);
      }
      chart.update("none");
      update24hStatsFromChart();

      if (backfillSeries.length) prevBasketLive = backfillSeries[backfillSeries.length - 1].fgi;

      el.textContent = `Backfill: loaded ${slice.length} points (1/min for 24h). Weights: ${weightsSummary()}`;
    }

    function weightsSummary() {
      return SYMBOLS.map(s => `${s}=${(WEIGHTS[s]*100).toFixed(1)}%`).join(" ");
    }

    // ----------------------------
    // Live WebSocket
    // ----------------------------
    let ws = null;
    let wsBackoffMs = 500;

    function connectWS() {
      const streams = [];
      for (const sym of SYMBOLS) {
        const s = sym.toLowerCase();
        streams.push(`${s}@aggTrade`);
        streams.push(`${s}@depth10@100ms`);
      }
      const url = `wss://stream.binance.com:9443/stream?streams=${streams.join("/")}`;
      ws = new WebSocket(url);

      ws.onopen = () => { setConn("connected"); wsBackoffMs = 500; };
      ws.onclose = () => {
        setConn("disconnected");
        setTimeout(connectWS, wsBackoffMs);
        wsBackoffMs = Math.min(15000, wsBackoffMs * 1.5);
      };
      ws.onerror = () => { try { ws.close(); } catch {} };

      ws.onmessage = (ev) => {
        let msg;
        try { msg = JSON.parse(ev.data); } catch { return; }
        const stream = msg.stream || "";
        const d = msg.data || {};

        const sym = stream.split("@")[0].toUpperCase();
        if (!liveStates[sym]) return;

        if (stream.endsWith("@aggTrade")) {
          liveStates[sym].onAggTrade(Number(d.E), Number(d.p), Number(d.q), Boolean(d.m));
          return;
        }
        if (stream.includes("@depth10")) {
          liveStates[sym].onDepth10(Number(d.E), d.b || [], d.a || []);
          return;
        }
      };
    }

    // ----------------------------
    // Live compute + UI
    // ----------------------------
    function updateTable(snapshotAssets) {
      const rows = document.getElementById("rows");
      rows.innerHTML = "";
      const keys = Object.keys(snapshotAssets).sort();
      for (const k of keys) {
        const a = snapshotAssets[k];
        const tr = document.createElement("tr");
        tr.innerHTML =
          `<td>${k}</td>` +
          `<td>${fmt(a.price, 2)}</td>` +
          `<td>${fmt(a.asset, 2)}</td>` +
          `<td>${fmt(a.mom, 2)}</td>` +
          `<td>${fmt(a.vol, 2)}</td>` +
          `<td>${fmt(a.ob, 2)}</td>` +
          `<td>${fmt(a.aggr, 2)}</td>`;
        rows.appendChild(tr);
      }
    }

    function computeLiveOnce() {
      const nowSec = Math.floor(Date.now() / 1000);

      const assets = {};
      let total = 0;
      let used = 0;

      for (const sym of SYMBOLS) {
        const sc = liveStates[sym].compute(nowSec);
        if (!sc) continue;
        assets[sym] = sc;

        const w = Number(WEIGHTS[sym] || 0);
        if (w > 0) {
          total += w * sc.asset;
          used += w;
        }
      }

      if (used <= 0) return null;

      const fgiRaw = clamp(total / (used + EPS));
      const fgi = clamp(BASKET_ALPHA_LIVE * fgiRaw + (1 - BASKET_ALPHA_LIVE) * prevBasketLive);
      prevBasketLive = fgi;

      return { t_sec: nowSec, fgi_raw: fgiRaw, fgi, assets };
    }

    function updateHeader(snap) {
      const fgiEl = document.getElementById("fgi");
      fgiEl.textContent = fmt(snap.fgi, 2);
      fgiEl.style.color = colorForFGI(snap.fgi);

      const dt = new Date(snap.t_sec * 1000);
      document.getElementById("meta").textContent =
        `live raw=${fmt(snap.fgi_raw,2)} | ${dt.toLocaleString()} | alpha=${BASKET_ALPHA_LIVE} | weights: ${weightsSummary()}`;
    }

    function maybeAppendChartPoint(snap) {
      const minute = Math.floor(snap.t_sec / CHART_POINT_SECONDS);
      if (lastChartMinute === null) lastChartMinute = minute;

      if (minute !== lastChartMinute) {
        lastChartMinute = minute;

        chart.data.labels.push(new Date(snap.t_sec * 1000).toLocaleTimeString());
        chart.data.datasets[0].data.push(snap.fgi);

        const maxPts = 24 * 60;
        while (chart.data.labels.length > maxPts) {
          chart.data.labels.shift();
          chart.data.datasets[0].data.shift();
        }
        chart.update("none");
        update24hStatsFromChart();
      }
    }

    // ----------------------------
    // Weights UI wiring
    // ----------------------------
    function initWeightsUI() {
      // Seed UI from WEIGHTS
      writeWeightsToUI(WEIGHTS);
      setWeightStatus(`Current: ${weightsSummary()}`);

      document.getElementById("btnNormalize").onclick = () => {
        const raw = readWeightsFromUI();
        const r = normalizeWeights(raw);
        if (!r.ok) return setWeightStatus(r.msg, true);
        writeWeightsToUI(r.weights);
        setWeightStatus(`Normalized preview: ${SYMBOLS.map(s => `${s}=${(r.weights[s]*100).toFixed(1)}%`).join(" ")}`);
      };

      document.getElementById("btnApply").onclick = async () => {
        setWeightStatus("Applying…");
        const raw = readWeightsFromUI();
        const r = normalizeWeights(raw);
        if (!r.ok) return setWeightStatus(r.msg, true);

        // Apply new weights
        WEIGHTS = r.weights;
        writeWeightsToUI(WEIGHTS);
        setWeightStatus(`Applied: ${weightsSummary()}`);

        // Recompute backfill chart with new weights
        try {
          await runBackfill();
          // Reset lastChartMinute so minute append logic stays sane after chart refresh
          lastChartMinute = null;

          // Also seed live EMA from latest chart point (prevents jumps)
          const data = chart?.data?.datasets?.[0]?.data || [];
          if (data.length) prevBasketLive = Number(data[data.length - 1]) || prevBasketLive;
        } catch (e) {
          setWeightStatus(`Apply failed: ${String(e.message || e)}`, true);
        }
      };
    }

    // ----------------------------
    // Boot
    // ----------------------------
    (async () => {
      initChart();
      initWeightsUI();
      setConn("disconnected");

      try {
        await runBackfill();
      } catch (e) {
        document.getElementById("backfill").textContent =
          `Backfill failed: ${String(e.message || e)}`;
      }

      connectWS();

      setInterval(() => {
        const snap = computeLiveOnce();
        if (!snap) return;

        updateHeader(snap);
        updateTable(snap.assets);
        maybeAppendChartPoint(snap);
      }, LIVE_UPDATE_EVERY_MS);
    })();
  </script>
</body>
</html>
