<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Live Crypto FGI (Option 1: No API Keys)</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 16px; }
    .card { border: 1px solid #ddd; border-radius: 12px; padding: 12px; margin-bottom: 12px; }
    .row { display:flex; gap:12px; flex-wrap:wrap; align-items:flex-start; }
    .col { flex:1 1 220px; }
    .muted { color: #666; }
    .small { font-size: 12px; }
    .pill { display:inline-block; padding:2px 8px; border-radius:999px; border:1px solid #ddd; font-size:12px; }
    canvas { width: 100%; max-height: 320px; }

    table { width: 100%; border-collapse: collapse; }
    th, td { text-align: left; padding: 8px; border-bottom: 1px solid #eee; font-size: 14px; }

    /* FGI tiles */
    .tile { border: 1px solid #eee; border-radius: 12px; padding: 10px; }
    .tileTitle { font-size: 12px; color: #666; margin-bottom: 4px; }
    .tileVal { font-size: 40px; font-weight: 700; line-height: 1.05; }
    .tileMeta { font-size: 12px; color: #666; margin-top: 4px; }

    /* warnings */
    .warnBox { margin-top: 10px; padding: 10px; border-radius: 10px; border: 1px solid; }
    .warnRed { background: #fff1f1; border-color: #f0b5b5; color: #7a0000; font-weight: 700; }
    .warnYellow { background: #fff9e6; border-color: #f0d48a; color: #6a5200; font-weight: 700; }

    /* weights UI */
    input[type="number"] { width: 120px; padding: 6px; border: 1px solid #ddd; border-radius: 8px; }
    button { padding: 8px 10px; border-radius: 10px; border: 1px solid #ddd; background: #f7f7f7; cursor: pointer; }
    button:hover { background: #efefef; }
    .err { color: #a40000; }

    /* prediction boxes */
    .predRow { display:flex; gap:12px; flex-wrap:wrap; margin-top:10px; }
    .predBox { flex:1 1 280px; border:1px solid #eee; border-radius:12px; padding:10px; }
    .predTitle { font-size:12px; color:#666; margin-bottom:4px; }
    .predVal { font-size:16px; font-weight:700; }
    .predMeta { font-size:12px; color:#666; margin-top:4px; }

    /* NEW: Events/news embeds */
    .embedWrap { width: 100%; border: 1px solid #eee; border-radius: 12px; overflow: hidden; }
    .embedHead { padding: 8px 10px; border-bottom: 1px solid #eee; background: #fafafa; font-size: 12px; color: #666; }
    .tvWrap { width: 100%; }
    .tvWrap > div, .tvWrap iframe { width: 100% !important; }
    .eventsTable th { font-size: 12px; color: #666; }
    .impactHigh { color:#7a0000; font-weight:700; }
    .impactMed { color:#6a5200; font-weight:700; }
    .impactLow { color:#666; font-weight:700; }
    .linkish { color:#0b57d0; text-decoration:none; }
    .linkish:hover { text-decoration: underline; }
  </style>
</head>
<body>

  <div class="card">
    <div class="row">
      <div class="col" style="flex:1 1 280px;">
        <div class="muted">Connection</div>
        <div id="conn" class="pill">disconnected</div>
        <div class="muted small" style="margin-top:8px;">
          Binance REST: <code>/api/v3/klines</code> (1m + 1d)<br/>
          Binance WS: <code>aggTrade</code> + <code>depth10</code><br/>
          Alternative.me: public API (no key)<br/>
          This page uses <b>No API keys</b>.
        </div>
      </div>

      <div class="col" style="flex: 3 1 560px;">
        <div class="muted">Fear &amp; Greed (Option 1: MyFGI + Alternative.me only)</div>

        <div class="row" style="margin-top:10px;">
          <div class="col tile" style="flex:1 1 260px;">
            <div class="tileTitle">Average FGI (renormalized: 0.10 My + 0.45 Alt)</div>
            <div id="avgFgi" class="tileVal">--</div>
            <div id="avgMeta" class="tileMeta"></div>
          </div>

          <div class="col tile" style="flex:1 1 220px;">
            <div class="tileTitle">MyFGI (BTC/ETH basket)</div>
            <div id="myFgi" class="tileVal">--</div>
            <div id="myMeta" class="tileMeta"></div>
          </div>

          <div class="col tile" style="flex:1 1 220px;">
            <div class="tileTitle">Alternative.me FGI</div>
            <div id="altFgi" class="tileVal">--</div>
            <div id="altMeta" class="tileMeta"></div>
          </div>
        </div>

        <div id="priceStats" class="muted small" style="margin-top:10px;"></div>

        <!-- RESTORED: Price prediction outputs -->
        <div class="predRow">
          <div class="predBox">
            <div class="predTitle">Predicted BTC (tomorrow / 1 week) using FGI avg windows</div>
            <div class="predVal" id="predBTC">--</div>
            <div class="predMeta" id="predBTCMeta"></div>
          </div>
          <div class="predBox">
            <div class="predTitle">Predicted ETH (tomorrow / 1 week) using FGI avg windows</div>
            <div class="predVal" id="predETH">--</div>
            <div class="predMeta" id="predETHMeta"></div>
          </div>
        </div>

        <div id="warnRed" class="warnBox warnRed" style="display:none;"></div>
        <div id="warnY1" class="warnBox warnYellow" style="display:none;"></div>
        <div id="warnY2" class="warnBox warnYellow" style="display:none;"></div>
      </div>
    </div>
  </div>

  <!-- NEW: Events & News (No-API embeds + manual key dates) -->
  <div class="card">
    <div class="muted">Events &amp; News (no API keys). Macro calendar + top headlines + your curated key dates.</div>

    <div class="row" style="margin-top:10px;">
      <div class="col" style="flex: 1 1 420px;">
        <div class="embedWrap">
          <div class="embedHead">Economic calendar (macro events)</div>
          <div class="tvWrap">
            <!-- TradingView Economic Calendar widget -->
            <div class="tradingview-widget-container">
              <div class="tradingview-widget-container__widget"></div>
              <script type="text/javascript" src="https://s3.tradingview.com/external-embedding/embed-widget-events.js" async>
              {
                "colorTheme": "light",
                "isTransparent": false,
                "width": "100%",
                "height": 520,
                "locale": "en",
                "importanceFilter": "0,1",
                "currencyFilter": "USD,EUR,GBP,JPY,CNY,NZD,AUD,CAD"
              }
              </script>
            </div>
          </div>
        </div>
      </div>

      <div class="col" style="flex: 1 1 420px;">
        <div class="embedWrap">
          <div class="embedHead">Top stories (market headlines)</div>
          <div class="tvWrap">
            <!-- TradingView Top Stories widget -->
            <div class="tradingview-widget-container">
              <div class="tradingview-widget-container__widget"></div>
              <script type="text/javascript" src="https://s3.tradingview.com/external-embedding/embed-widget-timeline.js" async>
              {
                "feedMode": "market",
                "market": "crypto",
                "colorTheme": "light",
                "isTransparent": false,
                "displayMode": "regular",
                "width": "100%",
                "height": 520,
                "locale": "en"
              }
              </script>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div style="margin-top:12px;" class="embedWrap">
      <div class="embedHead">Key crypto dates (edit inside the HTML)</div>
      <div style="padding: 8px 10px;">
        <div class="small muted" style="margin-bottom:8px;">
          Tip: Keep this to the 10–30 highest-signal items (major upgrades, ETF deadlines, token unlocks, big conferences).
        </div>
        <table class="eventsTable">
          <thead>
            <tr>
              <th style="width:130px;">Date (UTC)</th>
              <th>Event</th>
              <th style="width:90px;">Impact</th>
              <th style="width:110px;">In</th>
            </tr>
          </thead>
          <tbody id="keyDates"></tbody>
        </table>
        <div class="small muted" id="keyDatesMeta" style="margin-top:6px;"></div>
      </div>
    </div>
  </div>

  <div class="card">
    <div class="muted">MyFGI history (last 24h, 1 point/min). Backfill fetch uses last 72h to support “3+ days” warnings.</div>
    <canvas id="chart"></canvas>
    <div id="backfill" class="muted small" style="margin-top:8px;"></div>
    <div class="small muted" style="margin-top:6px;">
      Note: Binance does not provide historical order book. MyFGI backfill uses a candle-based proxy for OB; live uses real depth10 imbalance.
    </div>
  </div>

  <div class="card">
    <div class="muted">MyFGI basket weights (BTC/ETH only; auto-normalized)</div>
    <div class="row" style="margin-top:10px;">
      <div class="col">
        <div class="small muted">BTCUSDT</div>
        <input id="w_BTCUSDT" type="number" step="0.01" min="0" value="0.50"/>
      </div>
      <div class="col">
        <div class="small muted">ETHUSDT</div>
        <input id="w_ETHUSDT" type="number" step="0.01" min="0" value="0.50"/>
      </div>
    </div>
    <div class="row" style="margin-top:10px; align-items:center;">
      <button id="btnNormalize" type="button">Normalize</button>
      <button id="btnApply" type="button">Apply (recompute MyFGI chart + live)</button>
      <span id="wStatus" class="small muted"></span>
      <span id="wError" class="small err"></span>
    </div>
  </div>

  <div class="card">
    <div class="muted">Live per-asset components (MyFGI, computed from Binance WS)</div>
    <table>
      <thead>
        <tr>
          <th>Symbol</th><th>Price</th><th>Asset</th><th>Mom</th><th>Vol</th><th>OB</th><th>Agg</th>
        </tr>
      </thead>
      <tbody id="rows"></tbody>
    </table>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script>
    // ============================
    // CONFIG
    // ============================
    const SYMBOLS = ["BTCUSDT", "ETHUSDT"];

    // MyFGI weights (mutable via UI)
    let WEIGHTS = { "BTCUSDT": 0.50, "ETHUSDT": 0.50 };

    // Average weights requested previously (CoinGlass/CMC removed in Option 1).
    // We renormalize using only available sources (my + alt).
    const AVG_W_DESIRED = { my: 0.10, alt: 0.45 }; // sum=0.55; renormalize => my=0.1818 alt=0.8182

    const ALT_URL = "https://api.alternative.me/fng/?limit=500&format=json";

    // For averages + warnings we check both BTC and ETH
    const PRICE_SYMBOLS = ["BTCUSDT", "ETHUSDT"];

    const LIVE_UPDATE_EVERY_MS = 5000;
    const CHART_POINT_SECONDS = 60;

    // Smoothing
    const BASKET_ALPHA_LIVE = 0.10;
    const ALPHA_BACKFILL = 0.10;

    // RESTORED: K_MULT used only for predictions (same semantics as your python script)
    const K_MULT = 18.0;

    // NEW: Curated key dates (UTC). Edit this list.
    // date: YYYY-MM-DD (UTC), title: string, impact: "High"|"Medium"|"Low", link: optional
    const KEY_CRYPTO_DATES = [
      { date: "2026-02-01", title: "Example: Major protocol upgrade window (edit me)", impact: "High", link: "" },
      { date: "2026-02-12", title: "Example: ETF decision / deadline (edit me)", impact: "High", link: "" },
      { date: "2026-03-10", title: "Example: Large token unlock (edit me)", impact: "Medium", link: "" }
    ];

    // MyFGI params (seconds)
    const P = {
      mom_short_s: 120,
      mom_long_s: 3600,
      vol_short_s: 240,
      vol_long_s: 3600,
      imb_window_s: 20,
      aggr_window_s: 1200,

      k_m_short: 0.005,
      k_m_long: 0.02,
      k_v_short: 0.01,
      k_v_long: 0.02,

      mom_blend_short: 0.5,
      vol_blend_short: 0.5,

      w_mom: 0.35,
      w_vol: 0.25,
      w_ob: 0.20,
      w_aggr: 0.20,
    };

    const EPS = 1e-12;

    // ============================
    // HELPERS
    // ============================
    function clamp(x, lo=0, hi=100) {
      x = Number(x);
      if (!Number.isFinite(x)) return lo;
      return Math.max(lo, Math.min(hi, x));
    }

    function tanhScoreSigned(x, k) {
      return clamp(50 + 50 * Math.tanh(x / (k + EPS)));
    }

    function tanhScoreNegative(x, k) {
      return clamp(50 + 50 * Math.tanh((-x) / (k + EPS)));
    }

    function std(arr) {
      const n = arr.length;
      if (!n) return 0;
      let mean = 0;
      for (const v of arr) mean += v;
      mean /= n;
      let ss = 0;
      for (const v of arr) { const d = v - mean; ss += d*d; }
      return Math.sqrt(ss / n);
    }

    function fmt(x, d=2) {
      if (x === null || x === undefined || !Number.isFinite(x)) return "--";
      return Number(x).toFixed(d);
    }

    function colorForFGI(v) {
      if (!Number.isFinite(v)) return "black";
      if (v >= 60) return "red";
      if (v <= 40) return "green";
      return "black";
    }

    function setConn(status) {
      const el = document.getElementById("conn");
      el.textContent = status;
      el.style.background = (status === "connected") ? "#eef9ee" : "#fff3f3";
      el.style.borderColor = (status === "connected") ? "#b8e0b8" : "#f0b5b5";
    }

    function setTile(idVal, idMeta, v, meta) {
      const valEl = document.getElementById(idVal);
      const metaEl = document.getElementById(idMeta);
      valEl.textContent = fmt(v, 2);
      valEl.style.color = colorForFGI(v);
      metaEl.textContent = meta || "";
    }

    function normalizeWeights(obj) {
      const clean = {};
      let sum = 0;
      for (const sym of SYMBOLS) {
        const v = Number(obj[sym]);
        const w = (Number.isFinite(v) && v > 0) ? v : 0;
        clean[sym] = w;
        sum += w;
      }
      if (sum <= 0) return { ok: false, weights: null, msg: "Weights sum to 0. Enter at least one positive weight." };
      for (const sym of SYMBOLS) clean[sym] = clean[sym] / sum;
      return { ok: true, weights: clean, msg: "Normalized (sum=1)." };
    }

    function readWeightsFromUI() {
      return {
        "BTCUSDT": Number(document.getElementById("w_BTCUSDT").value),
        "ETHUSDT": Number(document.getElementById("w_ETHUSDT").value),
      };
    }

    function writeWeightsToUI(w) {
      document.getElementById("w_BTCUSDT").value = (Number(w["BTCUSDT"]) || 0).toFixed(4);
      document.getElementById("w_ETHUSDT").value = (Number(w["ETHUSDT"]) || 0).toFixed(4);
    }

    function setWeightStatus(msg, isError=false) {
      document.getElementById("wStatus").textContent = isError ? "" : msg;
      document.getElementById("wError").textContent = isError ? msg : "";
    }

    function weightsSummary() {
      return SYMBOLS.map(s => `${s}=${(WEIGHTS[s]*100).toFixed(1)}%`).join(" ");
    }

    function update24hStatsFromChart(chart) {
      const data = chart?.data?.datasets?.[0]?.data || [];
      if (!data.length) return { hi: null, lo: null, avg: null, n: 0 };

      let hi = -Infinity, lo = Infinity, sum = 0, n = 0;
      for (const v of data) {
        const x = Number(v);
        if (!Number.isFinite(x)) continue;
        if (x > hi) hi = x;
        if (x < lo) lo = x;
        sum += x; n++;
      }
      if (!n) return { hi: null, lo: null, avg: null, n: 0 };
      return { hi, lo, avg: sum/n, n };
    }

    function dayKeyUTC(tSec) {
      const d = new Date(tSec * 1000);
      return `${d.getUTCFullYear()}-${String(d.getUTCMonth()+1).padStart(2,"0")}-${String(d.getUTCDate()).padStart(2,"0")}`;
    }

    // NEW: Render curated key dates
    function daysUntilUTC(dateStr) {
      // dateStr in YYYY-MM-DD; interpret as UTC midnight
      const [Y,M,D] = dateStr.split("-").map(x => parseInt(x,10));
      const target = Date.UTC(Y, M-1, D, 0, 0, 0);
      const now = Date.now();
      const diffMs = target - now;
      return Math.floor(diffMs / (24*3600*1000));
    }

    function impactClass(impact) {
      const s = String(impact || "").toLowerCase();
      if (s.startsWith("high")) return "impactHigh";
      if (s.startsWith("med")) return "impactMed";
      return "impactLow";
    }

    function renderKeyDates() {
      const tbody = document.getElementById("keyDates");
      const meta = document.getElementById("keyDatesMeta");
      if (!tbody || !meta) return;

      const rows = (KEY_CRYPTO_DATES || [])
        .map(x => ({
          date: String(x.date || "").trim(),
          title: String(x.title || "").trim(),
          impact: String(x.impact || "Low").trim(),
          link: String(x.link || "").trim()
        }))
        .filter(x => /^\d{4}-\d{2}-\d{2}$/.test(x.date) && x.title.length)
        .sort((a,b)=> a.date.localeCompare(b.date));

      tbody.innerHTML = "";

      for (const r of rows) {
        const tr = document.createElement("tr");
        const du = daysUntilUTC(r.date);
        const inTxt = (du >= 0) ? `${du}d` : `${Math.abs(du)}d ago`;

        const titleHtml = r.link
          ? `<a class="linkish" href="${r.link}" target="_blank" rel="noopener noreferrer">${r.title}</a>`
          : `${r.title}`;

        tr.innerHTML =
          `<td>${r.date}</td>` +
          `<td>${titleHtml}</td>` +
          `<td class="${impactClass(r.impact)}">${r.impact}</td>` +
          `<td>${inTxt}</td>`;
        tbody.appendChild(tr);
      }

      meta.textContent = rows.length
        ? `Showing ${rows.length} items. Edit KEY_CRYPTO_DATES in the HTML to update.`
        : `No key dates configured. Add items to KEY_CRYPTO_DATES in the HTML.`;
    }

    // ============================
    // BINANCE REST
    // ============================
    async function fetchKlines(symbol, interval, startMs, endMs, limit=1000) {
      const url = new URL("https://api.binance.com/api/v3/klines");
      url.searchParams.set("symbol", symbol);
      url.searchParams.set("interval", interval);
      if (startMs != null) url.searchParams.set("startTime", String(startMs));
      if (endMs != null) url.searchParams.set("endTime", String(endMs));
      url.searchParams.set("limit", String(limit));

      const res = await fetch(url.toString(), { method: "GET" });
      if (!res.ok) {
        const txt = await res.text().catch(() => "");
        throw new Error(`Klines fetch failed ${res.status}: ${txt}`);
      }
      return await res.json();
    }

    // Fetch last N minutes of 1m candles, paginated
    async function fetchLastNMinutes1m(symbol, minutes) {
      const now = Date.now();
      const start = now - minutes * 60 * 1000;
      const out = [];

      // Binance max 1000 klines per request. Page forward.
      let cursor = start;
      const end = now;
      let guard = 0;

      while (cursor < end && guard < 25) {
        guard++;
        const batch = await fetchKlines(symbol, "1m", cursor, end, 1000);
        if (!batch.length) break;
        out.push(...batch);

        const lastOpen = batch[batch.length - 1][0];
        const next = lastOpen + 60 * 1000;
        if (next <= cursor) break;
        cursor = next;

        if (batch.length < 1000) break;
      }

      const map = new Map();
      for (const k of out) map.set(k[0], k);
      return Array.from(map.values()).sort((a,b)=>a[0]-b[0]);
    }

    async function fetchDailyCloses(symbol, days) {
      const now = Date.now();
      const start = now - days * 24 * 3600 * 1000;
      const kl = await fetchKlines(symbol, "1d", start, now, 1000);
      return kl.map(k => ({ tSec: Math.floor(k[0]/1000), close: Number(k[4]) }));
    }

    function klinesToSeries(klines) {
      const t = [], open=[], high=[], low=[], close=[], vol=[], takerBuy=[];
      for (const k of klines) {
        t.push(Math.floor(Number(k[0]) / 1000));
        open.push(Number(k[1])); high.push(Number(k[2])); low.push(Number(k[3]));
        close.push(Number(k[4])); vol.push(Number(k[5]));
        takerBuy.push(Number(k[9]));
      }
      return { t, open, high, low, close, vol, takerBuy };
    }

    function computeAssetFrom1m(series) {
      const { t, open, high, low, close, vol, takerBuy } = series;
      const n = t.length;

      const ret = new Array(n).fill(NaN);
      for (let i=1; i<n; i++) {
        const p0 = close[i-1], p1 = close[i];
        if (p0 > 0 && p1 > 0) ret[i] = Math.log(p1 / (p0 + EPS));
      }

      const ms = Math.max(1, Math.round(P.mom_short_s / 60));
      const ml = Math.max(1, Math.round(P.mom_long_s / 60));
      const vs = Math.max(1, Math.round(P.vol_short_s / 60));
      const vl = Math.max(1, Math.round(P.vol_long_s / 60));
      const iw = Math.max(1, Math.round(P.imb_window_s / 60));
      const aw = Math.max(1, Math.round(P.aggr_window_s / 60));

      const mom = new Array(n).fill(NaN);
      const volScore = new Array(n).fill(NaN);
      const ob = new Array(n).fill(NaN);
      const aggr = new Array(n).fill(NaN);
      const asset = new Array(n).fill(NaN);

      const imbProxy = new Array(n).fill(0);
      for (let i=0; i<n; i++) {
        const rng = (high[i] - low[i]);
        imbProxy[i] = (rng > 0) ? Math.max(-1, Math.min(1, (close[i] - open[i]) / (rng + EPS))) : 0;
      }

      for (let i=0; i<n; i++) {
        if (i - ms >= 0 && close[i-ms] > 0 && close[i] > 0) {
          const rS = Math.log(close[i] / (close[i-ms] + EPS));
          const momS = tanhScoreSigned(rS, P.k_m_short);

          let momVal = momS;
          if (i - ml >= 0 && close[i-ml] > 0) {
            const rL = Math.log(close[i] / (close[i-ml] + EPS));
            const momL = tanhScoreSigned(rL, P.k_m_long);
            const a = clamp(P.mom_blend_short, 0, 1);
            momVal = a * momS + (1 - a) * momL;
          }
          mom[i] = momVal;
        }

        const retsS = [];
        for (let j=Math.max(1, i - vs + 1); j<=i; j++) if (Number.isFinite(ret[j])) retsS.push(ret[j]);
        const volS = std(retsS);
        const volSScore = tanhScoreNegative(volS, P.k_v_short);

        const retsL = [];
        for (let j=Math.max(1, i - vl + 1); j<=i; j++) if (Number.isFinite(ret[j])) retsL.push(ret[j]);
        const volL = retsL.length ? std(retsL) : volS;
        const volLScore = tanhScoreNegative(volL, P.k_v_long);

        const aV = clamp(P.vol_blend_short, 0, 1);
        volScore[i] = aV * volSScore + (1 - aV) * volLScore;

        let sumImb = 0, cntImb = 0;
        for (let j=Math.max(0, i - iw + 1); j<=i; j++) { sumImb += imbProxy[j]; cntImb++; }
        ob[i] = clamp(50 + 50 * (cntImb ? (sumImb / cntImb) : 0));

        let bSum = 0, vSum = 0;
        for (let j=Math.max(0, i - aw + 1); j<=i; j++) { bSum += takerBuy[j]; vSum += vol[j]; }
        aggr[i] = (vSum > 0) ? clamp(100 * (bSum / (vSum + EPS))) : 50;

        if (Number.isFinite(mom[i])) {
          asset[i] = clamp(P.w_mom*mom[i] + P.w_vol*volScore[i] + P.w_ob*ob[i] + P.w_aggr*aggr[i]);
        }
      }

      return { t, close, asset };
    }

    // ============================
    // ALTERNATIVE.ME
    // ============================
    async function fetchAltFgiHistory() {
      const res = await fetch(ALT_URL, { method: "GET" });
      if (!res.ok) {
        const txt = await res.text().catch(()=> "");
        throw new Error(`Alternative.me fetch failed ${res.status}: ${txt}`);
      }
      const j = await res.json();
      const arr = j?.data || [];
      const parsed = arr
        .map(x => ({ tSec: Number(x.timestamp), value: Number(x.value), cls: String(x.value_classification||"") }))
        .filter(x => Number.isFinite(x.tSec) && Number.isFinite(x.value))
        .sort((a,b)=>a.tSec-b.tSec);
      return parsed;
    }

    // ============================
    // LIVE WS STATE (MyFGI live)
    // ============================
    class Rolling1s {
      constructor() { this.arr = []; }
      push(t, v) { this.arr.push({t, v}); }
      prune(cutoff) { while (this.arr.length && this.arr[0].t < cutoff) this.arr.shift(); }
      valuesSince(cutoff) { return this.arr.filter(x => x.t >= cutoff).map(x => x.v); }
      latest() { return this.arr.length ? this.arr[this.arr.length-1].v : null; }
    }

    class LiveSymbolState {
      constructor(symbol) {
        this.symbol = symbol;
        this.prices = new Rolling1s();
        this.rets = new Rolling1s();
        this.buy1s = new Rolling1s();
        this.sell1s = new Rolling1s();
        this.imb = new Rolling1s();

        this.curSec = null;
        this.curPrice = null;
        this.curBuy = 0;
        this.curSell = 0;

        this._lastRetPrice = null;
        this.lastPrice = null;
      }

      keepSec() {
        return Math.max(P.mom_long_s, P.vol_long_s, P.aggr_window_s, P.imb_window_s, 600) + 60;
      }

      prune(nowSec) {
        const cutoff = nowSec - this.keepSec();
        this.prices.prune(cutoff);
        this.rets.prune(cutoff);
        this.buy1s.prune(cutoff);
        this.sell1s.prune(cutoff);
        this.imb.prune(nowSec - (P.imb_window_s + 120));
      }

      flushSecond(sec, price, buyQty, sellQty) {
        this.prices.push(sec, price);
        if (this._lastRetPrice != null && this._lastRetPrice > 0 && price > 0) {
          this.rets.push(sec, Math.log(price / (this._lastRetPrice + EPS)));
        }
        this._lastRetPrice = price;

        this.buy1s.push(sec, buyQty);
        this.sell1s.push(sec, sellQty);
      }

      onAggTrade(eventMs, price, qty, isBuyerMaker) {
        const sec = Math.floor(eventMs / 1000);
        price = Number(price); qty = Number(qty);
        this.lastPrice = price;

        if (this.curSec === null) {
          this.curSec = sec;
          this.curPrice = price;
          this.curBuy = 0; this.curSell = 0;
        }

        if (sec === this.curSec) {
          this.curPrice = price;
          if (isBuyerMaker) this.curSell += qty; else this.curBuy += qty;
          return;
        }

        this.flushSecond(this.curSec, Number(this.curPrice ?? price), this.curBuy, this.curSell);

        const gap = sec - this.curSec;
        const fillMax = 30;
        if (gap > 1) {
          const lastP = Number(this.curPrice ?? price);
          const fillTo = Math.min(sec - 1, this.curSec + fillMax);
          for (let s=this.curSec + 1; s<=fillTo; s++) this.flushSecond(s, lastP, 0, 0);
        }

        this.curSec = sec;
        this.curPrice = price;
        this.curBuy = 0; this.curSell = 0;
        if (isBuyerMaker) this.curSell += qty; else this.curBuy += qty;

        this.prune(sec);
      }

      onDepth10(eventMs, bids, asks) {
        const sec = Math.floor(eventMs / 1000);
        let sumB = 0, sumA = 0;
        for (let i=0; i<Math.min(10, bids.length); i++) sumB += Number(bids[i][1]);
        for (let i=0; i<Math.min(10, asks.length); i++) sumA += Number(asks[i][1]);
        const imb = (sumB - sumA) / (sumB + sumA + EPS);
        this.imb.push(sec, imb);
        this.prune(sec);
      }

      priceAtOrAfter(targetSec) {
        for (const x of this.prices.arr) { if (x.t >= targetSec) return x.v; }
        return null;
      }

      compute(nowSec) {
        this.prune(nowSec);

        const pNow = this.prices.latest();
        if (!(pNow > 0)) return null;

        const pS = this.priceAtOrAfter(nowSec - P.mom_short_s);
        if (!(pS > 0)) return null;

        const rS = Math.log(pNow / (pS + EPS));
        const momS = tanhScoreSigned(rS, P.k_m_short);

        let mom = momS;
        const pL = this.priceAtOrAfter(nowSec - P.mom_long_s);
        if (pL && pL > 0) {
          const rL = Math.log(pNow / (pL + EPS));
          const momL = tanhScoreSigned(rL, P.k_m_long);
          const a = clamp(P.mom_blend_short, 0, 1);
          mom = a * momS + (1 - a) * momL;
        }

        const retsS = this.rets.valuesSince(nowSec - P.vol_short_s);
        const volS = std(retsS);
        const volSScore = tanhScoreNegative(volS, P.k_v_short);

        const retsL = this.rets.valuesSince(nowSec - P.vol_long_s);
        const volL = retsL.length ? std(retsL) : volS;
        const volLScore = tanhScoreNegative(volL, P.k_v_long);

        const aV = clamp(P.vol_blend_short, 0, 1);
        const vol = aV * volSScore + (1 - aV) * volLScore;

        const imbs = this.imb.valuesSince(nowSec - P.imb_window_s);
        let ob = 50;
        if (imbs.length) {
          const mean = imbs.reduce((a,b)=>a+b,0) / imbs.length;
          ob = clamp(50 + 50 * mean);
        }

        const buys = this.buy1s.valuesSince(nowSec - P.aggr_window_s);
        const sells = this.sell1s.valuesSince(nowSec - P.aggr_window_s);
        const bSum = buys.reduce((a,b)=>a+b,0);
        const sSum = sells.reduce((a,b)=>a+b,0);
        const aggr = (bSum + sSum > 0) ? clamp(100 * (bSum / (bSum + sSum + EPS))) : 50;

        const asset = clamp(P.w_mom*mom + P.w_vol*vol + P.w_ob*ob + P.w_aggr*aggr);

        return { symbol: this.symbol, t_sec: nowSec, price: pNow, mom, vol, ob, aggr, asset };
      }
    }

    const liveStates = {};
    for (const s of SYMBOLS) liveStates[s] = new LiveSymbolState(s);

    // ============================
    // CHART
    // ============================
    let chart = null;
    function initChart() {
      const ctx = document.getElementById("chart").getContext("2d");
      chart = new Chart(ctx, {
        type: "line",
        data: { labels: [], datasets: [{ label: "MyFGI (1/min)", data: [], borderWidth: 2, pointRadius: 0, tension: 0.25 }] },
        options: { responsive: true, animation: false, scales: { y: { min: 0, max: 100 } } }
      });
    }

    // ============================
    // MYFGI BACKFILL CACHE (72h)
    // ============================
    let backfillCache = null;
    let myFgiSeries = [];
    let prevBasketLive = 50.0;
    let lastChartMinute = null;

    async function loadMyFgiBackfill72h() {
      const el = document.getElementById("backfill");
      el.textContent = "MyFGI backfill: fetching 72h of 1m candles (BTC/ETH)…";

      const bySym = {};
      for (const sym of SYMBOLS) {
        el.textContent = `MyFGI backfill: fetching ${sym} 72h 1m…`;
        const kl = await fetchLastNMinutes1m(sym, 72*60);
        bySym[sym] = computeAssetFrom1m(klinesToSeries(kl));
      }

      const ref = bySym[SYMBOLS[0]].t;
      const has = {};
      for (const sym of SYMBOLS) has[sym] = new Set(bySym[sym].t);
      const commonT = ref.filter(ts => SYMBOLS.every(sym => has[sym].has(ts)));

      if (!commonT.length) {
        el.textContent = "MyFGI backfill: no overlapping timestamps across symbols.";
        backfillCache = null;
        return;
      }

      const idx = {};
      for (const sym of SYMBOLS) {
        idx[sym] = new Map();
        bySym[sym].t.forEach((ts, i) => idx[sym].set(ts, i));
      }

      backfillCache = { commonT, idx, bySym };
      el.textContent = `MyFGI backfill: cache ready (${commonT.length} minutes). Rendering MyFGI…`;

      recomputeMyFgiFromCache();
    }

    function recomputeMyFgiFromCache() {
      const el = document.getElementById("backfill");
      if (!backfillCache) { el.textContent = "MyFGI backfill: cache not ready."; return; }

      const { commonT, idx, bySym } = backfillCache;

      const out = [];
      let prev = 50.0;

      for (const ts of commonT) {
        let total = 0, used = 0;
        for (const sym of SYMBOLS) {
          const i = idx[sym].get(ts);
          const a = bySym[sym].asset[i];
          const w = Number(WEIGHTS[sym] || 0);
          if (Number.isFinite(a) && w > 0) { total += w * a; used += w; }
        }
        if (used <= 0) continue;

        const fgiRaw = clamp(total / (used + EPS));
        const fgi = clamp(ALPHA_BACKFILL * fgiRaw + (1 - ALPHA_BACKFILL) * prev);
        prev = fgi;
        out.push({ t_sec: ts, fgi_raw: fgiRaw, fgi });
      }

      myFgiSeries = out;

      const maxPts = 24*60;
      const slice = myFgiSeries.slice(-maxPts);

      chart.data.labels = [];
      chart.data.datasets[0].data = [];
      for (const p of slice) {
        chart.data.labels.push(new Date(p.t_sec*1000).toLocaleTimeString());
        chart.data.datasets[0].data.push(p.fgi);
      }
      chart.update("none");

      if (myFgiSeries.length) prevBasketLive = myFgiSeries[myFgiSeries.length-1].fgi;

      const stats = update24hStatsFromChart(chart);
      el.textContent =
        `MyFGI backfill: rendered ${slice.length} pts (24h). 24h high=${fmt(stats.hi)} low=${fmt(stats.lo)} avg=${fmt(stats.avg)}.`;
    }

    function computeMyFgiDailyAveragesLast3Days() {
      const map = new Map();
      for (const p of myFgiSeries) {
        const k = dayKeyUTC(p.t_sec);
        if (!map.has(k)) map.set(k, { sum: 0, n: 0 });
        const o = map.get(k);
        if (Number.isFinite(p.fgi)) { o.sum += p.fgi; o.n += 1; }
      }
      const days = Array.from(map.entries())
        .map(([k,v]) => ({ day: k, avg: (v.n ? v.sum/v.n : NaN) }))
        .filter(x => Number.isFinite(x.avg))
        .sort((a,b)=> a.day.localeCompare(b.day));

      return days.slice(-3);
    }

    // ============================
    // PRICE AVERAGES (BTC + ETH)
    // ============================
    let dailyCloses = { "BTCUSDT": null, "ETHUSDT": null }; // each: [{tSec, close}]
    let lastTradePrice = { "BTCUSDT": null, "ETHUSDT": null };

    function avgLastNCloses(symbol, n) {
      const s = dailyCloses[symbol];
      if (!s || s.length < n) return null;
      const arr = s.slice(-n).map(x => x.close).filter(v => Number.isFinite(v));
      if (arr.length < n) return null;
      const sum = arr.reduce((a,b)=>a+b,0);
      return sum / arr.length;
    }

    async function loadDailyClosesAll() {
      // fetch enough for 90 days + buffer
      for (const sym of PRICE_SYMBOLS) {
        dailyCloses[sym] = await fetchDailyCloses(sym, 120);
      }
    }

    function getPriceNow(symbol) {
      return (lastTradePrice[symbol] != null)
        ? lastTradePrice[symbol]
        : (dailyCloses[symbol]?.length ? dailyCloses[symbol][dailyCloses[symbol].length-1].close : null);
    }

    function updatePriceStatsUI() {
      const btc = {
        p: getPriceNow("BTCUSDT"),
        a7: avgLastNCloses("BTCUSDT", 7),
        a30: avgLastNCloses("BTCUSDT", 30),
        a60: avgLastNCloses("BTCUSDT", 60),
        a90: avgLastNCloses("BTCUSDT", 90),
      };
      const eth = {
        p: getPriceNow("ETHUSDT"),
        a7: avgLastNCloses("ETHUSDT", 7),
        a30: avgLastNCloses("ETHUSDT", 30),
        a60: avgLastNCloses("ETHUSDT", 60),
        a90: avgLastNCloses("ETHUSDT", 90),
      };

      document.getElementById("priceStats").textContent =
        `BTC price=${fmt(btc.p,2)} | 7d avg=${fmt(btc.a7,2)} | 30d avg=${fmt(btc.a30,2)} | 60d avg=${fmt(btc.a60,2)} | 90d avg=${fmt(btc.a90,2)}   ||   ` +
        `ETH price=${fmt(eth.p,2)} | 7d avg=${fmt(eth.a7,2)} | 30d avg=${fmt(eth.a30,2)} | 60d avg=${fmt(eth.a60,2)} | 90d avg=${fmt(eth.a90,2)}`;

      return { btc, eth };
    }

    // ============================
    // AVERAGE FGI (Option 1: My + Alt only)
    // ============================
    function computeAvgFgi(my, alt) {
      const wMy = Number(AVG_W_DESIRED.my || 0);
      const wAlt = Number(AVG_W_DESIRED.alt || 0);

      const hasMy = Number.isFinite(my);
      const hasAlt = Number.isFinite(alt);

      const sumAvail = (hasMy ? wMy : 0) + (hasAlt ? wAlt : 0);
      if (sumAvail <= 0) return { avg: NaN, meta: "avg unavailable (missing sources)" };

      const myN = hasMy ? (wMy / sumAvail) : 0;
      const altN = hasAlt ? (wAlt / sumAvail) : 0;

      const avg = clamp(myN*my + altN*alt);
      const meta = `using renormalized weights: my=${(myN*100).toFixed(1)}% alt=${(altN*100).toFixed(1)}%`;
      return { avg, meta };
    }

    // ============================
    // WARNINGS
    // ============================
    function setWarn(id, show, msg) {
      const el = document.getElementById(id);
      if (!show) { el.style.display = "none"; el.textContent = ""; return; }
      el.style.display = "block";
      el.textContent = msg;
    }

    function evaluateWarnings(avgFgiNow, pricePack, avgFgiDailyLast3) {
      const btc = pricePack.btc;
      const eth = pricePack.eth;

      const parts = [];

      function addRedFor(symbolName, p, a30, a60, a90) {
        const cond30 = (Number.isFinite(p) && Number.isFinite(a30) && p > a30 * 1.05 && Number.isFinite(avgFgiNow) && avgFgiNow < 40);
        const cond60 = (Number.isFinite(p) && Number.isFinite(a60) && p > a60 * 1.05 && Number.isFinite(avgFgiNow) && avgFgiNow < 40);
        const cond90 = (Number.isFinite(p) && Number.isFinite(a90) && p > a90 * 1.05 && Number.isFinite(avgFgiNow) && avgFgiNow < 40);

        if (cond30) parts.push(`${symbolName}: price > 30d avg * 1.05 AND avg FGI < 40`);
        if (cond60) parts.push(`${symbolName}: price > 60d avg * 1.05 AND avg FGI < 40`);
        if (cond90) parts.push(`${symbolName}: price > 90d avg * 1.05 AND avg FGI < 40`);
      }

      addRedFor("BTC", btc.p, btc.a30, btc.a60, btc.a90);
      addRedFor("ETH", eth.p, eth.a30, eth.a60, eth.a90);

      setWarn("warnRed", parts.length > 0, parts.length ? `RED WARNING: ${parts.join(" | ")}` : "");

      const y1 = (Number.isFinite(avgFgiNow) && avgFgiNow > 50);
      setWarn("warnY1", y1, y1 ? "WARNING: average FGI > 50, use reduced leverage" : "");

      let y2 = false;
      if (avgFgiDailyLast3 && avgFgiDailyLast3.length >= 3) {
        y2 = avgFgiDailyLast3.slice(-3).every(x => Number.isFinite(x.avg) && x.avg < 37);
      }
      setWarn("warnY2", y2, y2 ? "WARNING: FGI < 37 for 3 or more days, possible drawdown, use reduced leverage" : "");
    }

    // ============================
    // RESTORED: PRICE PREDICTIONS (k_fit * K_MULT) USING AVG FGI 2D/7D
    // ============================
    function centeredFgi(v) {
      return Number.isFinite(v) ? (Number(v) - 50.0) : NaN;
    }

    function mean(arr) {
      const xs = arr.filter(x => Number.isFinite(x));
      if (!xs.length) return NaN;
      return xs.reduce((a,b)=>a+b,0) / xs.length;
    }

    // Fit k (no intercept) for dP ≈ k*(FGI-50)*dt over daily history
    function fitKLeastSquares(priceSeries, fgiSeries) {
      // priceSeries: [{tSec, close}] daily close
      // fgiSeries: Map dayKey -> fgi (0..100) (we'll align using dayKeyUTC)
      if (!priceSeries || priceSeries.length < 10) return NaN;

      let prev = null;
      const x = [];
      const y = [];

      for (const row of priceSeries) {
        const day = dayKeyUTC(row.tSec);
        const fgi = fgiSeries.get(day);
        if (!Number.isFinite(fgi)) { prev = row.close; continue; }
        if (prev == null || !Number.isFinite(prev) || !Number.isFinite(row.close)) { prev = row.close; continue; }

        const dP = row.close - prev;
        const fc = centeredFgi(fgi); // (FGI-50)
        x.push(fc);
        y.push(dP);

        prev = row.close;
      }

      if (x.length < 10) return NaN;

      let denom = 0, numer = 0;
      for (let i=0; i<x.length; i++) {
        denom += x[i]*x[i];
        numer += x[i]*y[i];
      }
      if (denom <= 0) return NaN;
      return numer / denom;
    }

    function buildDailyAvgFgiSeries(myFgiSeriesMinutes, altHistoryDaily) {
      const myByDay = new Map();
      for (const p of (myFgiSeriesMinutes || [])) {
        const day = dayKeyUTC(p.t_sec);
        const o = myByDay.get(day) || { sum:0, n:0 };
        if (Number.isFinite(p.fgi)) { o.sum += p.fgi; o.n += 1; }
        myByDay.set(day, o);
      }
      const myAvg = new Map();
      for (const [day, o] of myByDay.entries()) {
        if (o.n) myAvg.set(day, o.sum/o.n);
      }

      const altMap = new Map();
      for (const a of (altHistoryDaily || [])) {
        const day = dayKeyUTC(a.tSec);
        if (Number.isFinite(a.value)) altMap.set(day, clamp(a.value));
      }

      const days = new Set([...myAvg.keys(), ...altMap.keys()]);
      const out = new Map();
      for (const day of days) {
        const my = myAvg.has(day) ? myAvg.get(day) : NaN;
        const alt = altMap.has(day) ? altMap.get(day) : NaN;
        const r = computeAvgFgi(my, alt);
        if (Number.isFinite(r.avg)) out.set(day, r.avg);
      }
      return out;
    }

    function computePredictions(avgFgiDailyMap, symbol) {
      const closes = dailyCloses[symbol];
      if (!closes || closes.length < 30 || !avgFgiDailyMap) {
        return { ok:false, msg:"insufficient data" };
      }

      const k_fit = fitKLeastSquares(closes, avgFgiDailyMap);
      const k_used = (Number.isFinite(k_fit) ? k_fit : 0) * Number(K_MULT);

      const daysSorted = Array.from(avgFgiDailyMap.keys()).sort();
      if (!daysSorted.length) return { ok:false, msg:"no daily avg fgi" };

      const lastDays = daysSorted.slice(-14);
      const vals = lastDays.map(d => avgFgiDailyMap.get(d));

      const fgi2 = mean(vals.slice(-2));
      const fgi7 = mean(vals.slice(-7));

      const p0 = getPriceNow(symbol);
      if (!Number.isFinite(p0)) return { ok:false, msg:"no current price" };

      const fc2 = centeredFgi(fgi2);
      const fc7 = centeredFgi(fgi7);

      const p_tom_2 = p0 + k_used * fc2 * 1.0;
      const p_tom_7 = p0 + k_used * fc7 * 1.0;
      const p_wk_2  = p0 + k_used * fc2 * 7.0;
      const p_wk_7  = p0 + k_used * fc7 * 7.0;

      return {
        ok: true,
        k_fit,
        k_used,
        fgi2,
        fgi7,
        p0,
        p_tom_2, p_tom_7,
        p_wk_2,  p_wk_7,
      };
    }

    function updatePredictionsUI(avgFgiDailyMap) {
      const btc = computePredictions(avgFgiDailyMap, "BTCUSDT");
      const eth = computePredictions(avgFgiDailyMap, "ETHUSDT");

      if (btc.ok) {
        document.getElementById("predBTC").textContent =
          `Tomorrow: (2d FGI) ${fmt(btc.p_tom_2,2)} | (7d FGI) ${fmt(btc.p_tom_7,2)}   ||   ` +
          `1 week: (2d FGI) ${fmt(btc.p_wk_2,2)} | (7d FGI) ${fmt(btc.p_wk_7,2)}`;
        document.getElementById("predBTCMeta").textContent =
          `BTC p0=${fmt(btc.p0,2)} | FGI2=${fmt(btc.fgi2,2)} FGI7=${fmt(btc.fgi7,2)} | k_fit=${fmt(btc.k_fit,6)} | K_MULT=${K_MULT} | k_used=${fmt(btc.k_used,6)}`;
      } else {
        document.getElementById("predBTC").textContent = "--";
        document.getElementById("predBTCMeta").textContent = `BTC prediction unavailable: ${btc.msg || "unknown"}`;
      }

      if (eth.ok) {
        document.getElementById("predETH").textContent =
          `Tomorrow: (2d FGI) ${fmt(eth.p_tom_2,2)} | (7d FGI) ${fmt(eth.p_tom_7,2)}   ||   ` +
          `1 week: (2d FGI) ${fmt(eth.p_wk_2,2)} | (7d FGI) ${fmt(eth.p_wk_7,2)}`;
        document.getElementById("predETHMeta").textContent =
          `ETH p0=${fmt(eth.p0,2)} | FGI2=${fmt(eth.fgi2,2)} FGI7=${fmt(eth.fgi7,2)} | k_fit=${fmt(eth.k_fit,6)} | K_MULT=${K_MULT} | k_used=${fmt(eth.k_used,6)}`;
      } else {
        document.getElementById("predETH").textContent = "--";
        document.getElementById("predETHMeta").textContent = `ETH prediction unavailable: ${eth.msg || "unknown"}`;
      }
    }

    // ============================
    // LIVE WS (Binance)
    // ============================
    let ws = null;
    let wsBackoffMs = 500;

    function connectWS() {
      const streams = [];
      for (const sym of SYMBOLS) {
        const s = sym.toLowerCase();
        streams.push(`${s}@aggTrade`);
        streams.push(`${s}@depth10@100ms`);
      }
      const url = `wss://stream.binance.com:9443/stream?streams=${streams.join("/")}`;
      ws = new WebSocket(url);

      ws.onopen = () => { setConn("connected"); wsBackoffMs = 500; };
      ws.onclose = () => {
        setConn("disconnected");
        setTimeout(connectWS, wsBackoffMs);
        wsBackoffMs = Math.min(15000, wsBackoffMs * 1.5);
      };
      ws.onerror = () => { try { ws.close(); } catch {} };

      ws.onmessage = (ev) => {
        let msg;
        try { msg = JSON.parse(ev.data); } catch { return; }
        const stream = msg.stream || "";
        const d = msg.data || {};

        const sym = stream.split("@")[0].toUpperCase();
        if (!liveStates[sym]) return;

        if (stream.endsWith("@aggTrade")) {
          liveStates[sym].onAggTrade(Number(d.E), Number(d.p), Number(d.q), Boolean(d.m));
          if (sym === "BTCUSDT" || sym === "ETHUSDT") lastTradePrice[sym] = Number(d.p);
          return;
        }
        if (stream.includes("@depth10")) {
          liveStates[sym].onDepth10(Number(d.E), d.b || [], d.a || []);
          return;
        }
      };
    }

    // ============================
    // LIVE COMPUTE + UI
    // ============================
    function updateTable(snapshotAssets) {
      const rows = document.getElementById("rows");
      rows.innerHTML = "";
      const keys = Object.keys(snapshotAssets).sort();
      for (const k of keys) {
        const a = snapshotAssets[k];
        const tr = document.createElement("tr");
        tr.innerHTML =
          `<td>${k}</td>` +
          `<td>${fmt(a.price, 2)}</td>` +
          `<td>${fmt(a.asset, 2)}</td>` +
          `<td>${fmt(a.mom, 2)}</td>` +
          `<td>${fmt(a.vol, 2)}</td>` +
          `<td>${fmt(a.ob, 2)}</td>` +
          `<td>${fmt(a.aggr, 2)}</td>`;
        rows.appendChild(tr);
      }
    }

    function computeMyFgiLiveOnce() {
      const nowSec = Math.floor(Date.now() / 1000);

      const assets = {};
      let total = 0, used = 0;

      for (const sym of SYMBOLS) {
        const sc = liveStates[sym].compute(nowSec);
        if (!sc) continue;
        assets[sym] = sc;

        const w = Number(WEIGHTS[sym] || 0);
        if (w > 0) { total += w * sc.asset; used += w; }
      }

      if (used <= 0) return null;

      const fgiRaw = clamp(total / (used + EPS));
      const fgi = clamp(BASKET_ALPHA_LIVE * fgiRaw + (1 - BASKET_ALPHA_LIVE) * prevBasketLive);
      prevBasketLive = fgi;

      return { t_sec: nowSec, fgi_raw: fgiRaw, fgi, assets };
    }

    function maybeAppendChartPoint(mySnap) {
      const minute = Math.floor(mySnap.t_sec / CHART_POINT_SECONDS);
      if (lastChartMinute === null) lastChartMinute = minute;

      if (minute !== lastChartMinute) {
        lastChartMinute = minute;

        chart.data.labels.push(new Date(mySnap.t_sec * 1000).toLocaleTimeString());
        chart.data.datasets[0].data.push(mySnap.fgi);

        const maxPts = 24 * 60;
        while (chart.data.labels.length > maxPts) {
          chart.data.labels.shift();
          chart.data.datasets[0].data.shift();
        }
        chart.update("none");
      }
    }

    // ============================
    // EXTERNAL FGI STATE
    // ============================
    let altHistory = null;
    let altNow = NaN;
    let altNowMeta = "";

    async function refreshAlt() {
      altHistory = await fetchAltFgiHistory();
      if (altHistory && altHistory.length) {
        const last = altHistory[altHistory.length - 1];
        altNow = clamp(last.value);
        altNowMeta = `${last.cls || ""} | ${new Date(last.tSec*1000).toLocaleString()}`;
      }
    }

    function computeAltDailyLast3() {
      if (!altHistory || altHistory.length < 3) return [];
      return altHistory.slice(-3).map(x => ({ day: dayKeyUTC(x.tSec), avg: clamp(x.value) }));
    }

    // ============================
    // WEIGHTS UI WIRING
    // ============================
    function initWeightsUI() {
      const r0 = normalizeWeights(WEIGHTS);
      if (r0.ok) WEIGHTS = r0.weights;

      writeWeightsToUI(WEIGHTS);
      setWeightStatus(`Current: ${weightsSummary()}`);

      document.getElementById("btnNormalize").onclick = () => {
        const raw = readWeightsFromUI();
        const r = normalizeWeights(raw);
        if (!r.ok) return setWeightStatus(r.msg, true);
        writeWeightsToUI(r.weights);
        setWeightStatus(`Normalized preview: BTC=${(r.weights["BTCUSDT"]*100).toFixed(1)}% ETH=${(r.weights["ETHUSDT"]*100).toFixed(1)}%`);
      };

      document.getElementById("btnApply").onclick = () => {
        setWeightStatus("Applying…");
        const raw = readWeightsFromUI();
        const r = normalizeWeights(raw);
        if (!r.ok) return setWeightStatus(r.msg, true);

        WEIGHTS = r.weights;
        writeWeightsToUI(WEIGHTS);

        // Recompute MyFGI backfill + reseed live EMA to avoid a jump
        recomputeMyFgiFromCache();
        lastChartMinute = null;

        setWeightStatus(`Applied: ${weightsSummary()}`);
      };
    }

    // ============================
    // BOOT
    // ============================
    (async () => {
      initChart();
      initWeightsUI();
      setConn("disconnected");

      // NEW: render manual key dates (no network needed)
      renderKeyDates();

      try {
        await loadDailyClosesAll();
      } catch (e) {
        document.getElementById("priceStats").textContent = `Daily close load failed: ${String(e.message || e)}`;
      }

      try {
        await loadMyFgiBackfill72h();
      } catch (e) {
        document.getElementById("backfill").textContent = `MyFGI backfill failed: ${String(e.message || e)}`;
      }

      try {
        await refreshAlt();
      } catch (e) {
        altNow = NaN;
        altNowMeta = `Alternative.me fetch failed: ${String(e.message || e)}`;
      }

      connectWS();

      setInterval(async () => {
        try { await refreshAlt(); } catch {}
      }, 60 * 1000);

      setInterval(() => {
        const mySnap = computeMyFgiLiveOnce();
        if (!mySnap) return;

        // Update MyFGI tile
        setTile(
          "myFgi",
          "myMeta",
          mySnap.fgi,
          `raw=${fmt(mySnap.fgi_raw,2)} | alpha=${BASKET_ALPHA_LIVE} | weights: ${weightsSummary()} | ${new Date(mySnap.t_sec*1000).toLocaleString()}`
        );

        // Update Alt tile
        setTile("altFgi", "altMeta", altNow, altNowMeta);

        // Compute AVG (renormalized on available sources)
        const { avg, meta } = computeAvgFgi(mySnap.fgi, altNow);
        setTile("avgFgi", "avgMeta", avg, meta);

        // Update price stats + warnings
        const pricePack = updatePriceStatsUI();

        // Daily series for 3+ days check
        const myDaily = computeMyFgiDailyAveragesLast3Days();
        const altDaily = computeAltDailyLast3();

        const byDay = new Map();
        for (const x of myDaily) byDay.set(x.day, { day: x.day, my: x.avg, alt: NaN });
        for (const x of altDaily) {
          const o = byDay.get(x.day) || { day: x.day, my: NaN, alt: NaN };
          o.alt = x.avg;
          byDay.set(x.day, o);
        }
        const dailyMerged = Array.from(byDay.values()).sort((a,b)=>a.day.localeCompare(b.day));

        const avgDaily = dailyMerged.map(d => {
          const r = computeAvgFgi(d.my, d.alt);
          return { day: d.day, avg: r.avg };
        }).filter(x => Number.isFinite(x.avg));

        evaluateWarnings(avg, pricePack, avgDaily);

        // RESTORED: predictions (uses daily closes + daily avg fgi series)
        const avgFgiDailyMap = buildDailyAvgFgiSeries(myFgiSeries, altHistory);
        updatePredictionsUI(avgFgiDailyMap);

        // Update per-asset table
        updateTable(mySnap.assets);

        // Update chart
        maybeAppendChartPoint(mySnap);

      }, LIVE_UPDATE_EVERY_MS);
    })();
  </script>
</body>
</html>
